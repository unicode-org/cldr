<!DOCTYPE html>
<html><head><meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="../reports-v2.css">
<title>Unicode Locale Data Markup Language (LDML) Part 7: Keyboards</title></head><body>



























































































































































































































































































































































































































































































































































<script src="./js/anchor.min.js"></script><div class="header"><table class="header" cellpadding="0" cellspacing="0" width="100%">
  <tbody>
      <tr>
          <td class="icon"><a href="http://www.unicode.org/"><img style="vertical-align:middle;border:0" alt="[Unicode]" src="http://www.unicode.org/webscripts/logo60s2.gif" height="33" width="34"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/reports/">Technical Reports</a></td>
      </tr>
      <tr>
          <td class="gray">&nbsp;</td>
      </tr>
  </tbody>
  </table></div><div class="body"><h2 id="unicode-technical-standard-35">Unicode Technical Standard #35</h2><h1 id="unicode-locale-data-markup-language-ldmlpart-7-keyboards">Unicode Locale Data Markup Language (LDML)<br>Part 7: Keyboards</h1><!-- HTML: no th --><table class="simple" width="90%"><tbody>
<tr><td>Version</td><td>41</td></tr>
<tr><td>Editors</td><td>Steven Loomis (<a href="mailto:srl@icu-project.org">srl@icu-project.org</a>) and <a href="tr35.html#Acknowledgments">other CLDR committee members</a></td></tr>
</tbody></table><p>For the full header, summary, and status, see <a href="tr35.html">Part 1: Core</a>.</p><h4 id="important-note"><em>Important Note</em></h4><blockquote>
<p>The CLDR <a href="https://cldr.unicode.org/index/keyboard-workgroup">Keyboard Workgroup</a> is currently
developing major changes to the CLDR keyboard specification. These changes are targeted for
CLDR version 41. Please see <a href="https://unicode-org.atlassian.net/browse/CLDR-15034">CLDR-15034</a> for
the latest information.</p>
</blockquote><h3 id="summary"><em>Summary</em></h3><p>This document describes parts of an XML format (<em>vocabulary</em>) for the exchange of structured locale data. This format is used in the <a href="https://unicode.org/cldr/">Unicode Common Locale Data Repository</a>.</p><p>This is a partial document, describing keyboard mappings. For the other parts of the LDML see the <a href="tr35.html">main LDML document</a> and the links above.</p><h3 id="status"><em>Status</em></h3><p><em>This is a draft document which may be updated, replaced, or superseded by other documents at any time. Publication does not imply endorsement by the Unicode Consortium. This is not a stable document; it is inappropriate to cite this document as other than a work in progress.</em></p><blockquote>
<p><em><strong>A Unicode Technical Standard (UTS)</strong> is an independent specification. Conformance to the Unicode Standard does not imply conformance to any UTS.</em></p>
</blockquote><p><em>Please submit corrigenda and other comments with the CLDR bug reporting form [<a href="tr35.html#Bugs">Bugs</a>]. Related information that is useful in understanding this document is found in the <a href="tr35.html#References">References</a>. For the latest version of the Unicode Standard see [<a href="tr35.html#Unicode">Unicode</a>]. For a list of current Unicode Technical Reports see [<a href="tr35.html#Reports">Reports</a>]. For more information about versions of the Unicode Standard, see [<a href="tr35.html#Versions">Versions</a>].</em></p><h2 id="parts"><a name="Parts" href="#Parts">Parts</a></h2><p>The LDML specification is divided into the following parts:</p><ul>
<li>  Part 1: <a href="tr35.html#Contents">Core</a> (languages, locales, basic structure)</li>
<li>  Part 2: <a href="tr35-general.html#Contents">General</a> (display names &amp; transforms, etc.)</li>
<li>  Part 3: <a href="tr35-numbers.html#Contents">Numbers</a> (number &amp; currency formatting)</li>
<li>  Part 4: <a href="tr35-dates.html#Contents">Dates</a> (date, time, time zone formatting)</li>
<li>  Part 5: <a href="tr35-collation.html#Contents">Collation</a> (sorting, searching, grouping)</li>
<li>  Part 6: <a href="tr35-info.html#Contents">Supplemental</a> (supplemental data)</li>
<li>  Part 7: <a href="tr35-keyboards.html#Contents">Keyboards</a> (keyboard mappings)</li>
</ul><h2 id="contents-of-part-7-keyboards"><a name="Contents" href="#Contents">Contents of Part 7, Keyboards</a></h2><ul>
<li>  1 <a href="#Introduction">Keyboards</a></li>
<li>  2 <a href="#Goals_and_Nongoals">Goals and Non-goals</a></li>
<li>  3 <a href="#Definitions">Definitions</a></li>
<li>  4 <a href="#File_and_Dir_Structure">File and Directory Structure</a></li>
<li>5 <a href="#Element_Heirarchy_Layout_File">Element Hierarchy - Layout File</a><ul>
<li>  5.1 <a href="#Element_Keyboard">Element: keyboard</a></li>
<li>  5.2 <a href="#Element_version">Element: version</a></li>
<li>  5.3 <a href="#Element_generation">Element: generation</a></li>
<li>  5.4 <a href="#Element_info">Element: info</a></li>
<li>  5.5 <a href="#Element_names">Element: names</a></li>
<li>  5.6 <a href="#Element_name">Element: name</a></li>
<li>  5.7 <a href="#Element_settings">Element: settings</a></li>
<li>5.8 <a href="#Element_keyMap">Element: keyMap</a><ul>
<li>  Table: <a href="#Possible_Modifier_Keys">Possible Modifier Keys</a></li>
</ul>
</li>
<li>5.9 <a href="#Element_map">Element: map</a><ul>
<li>  5.9.1 <a href="#Element_flicks">Element: flicks, flick</a></li>
</ul>
</li>
<li>  5.10 <a href="#Element_import">Element: import</a></li>
<li>  5.11 <a href="#Element_displayMap">Element: displayMap</a></li>
<li>  5.12 <a href="#Element_display">Element: display</a></li>
<li>  5.13 <a href="#Element_layer">Element: layer</a></li>
<li>  5.14 <a href="#Element_row">Element: row</a></li>
<li>  5.15 <a href="#Element_switch">Element: switch</a></li>
<li>  5.16 <a href="#Element_vkeys">Element: vkeys</a></li>
<li>  5.17 <a href="#Element_vkey">Element: vkey</a></li>
<li>  5.18 <a href="#Element_transforms">Element: transforms</a></li>
<li>  5.19 <a href="#Element_transform">Element: transform</a></li>
<li>  5.20 <a href="#Element_reorder">Element: reorders, reorder</a></li>
<li>  5.21 <a href="#Element_final">Element: transform final</a></li>
<li>  5.22 <a href="#Element_backspaces">Element: backspaces</a></li>
<li>  5.23 <a href="#Element_backspace">Element: backspace</a></li>
</ul>
</li>
<li>6 <a href="#Element_Heirarchy_Platform_File">Element Hierarchy - Platform File</a><ul>
<li>  6.1 <a href="#Element_platform">Element: platform</a></li>
<li>  6.2 <a href="#Element_hardwareMap">Element: hardwareMap</a></li>
<li>  6.3 <a href="#Element_hardwareMap_map">Element: map</a></li>
</ul>
</li>
<li>  7 <a href="#Invariants">Invariants</a></li>
<li>8 <a href="#Data_Sources">Data Sources</a><ul>
<li>  Table: <a href="#Key_Map_Data_Sources">Key Map Data Sources</a></li>
</ul>
</li>
<li>9 <a href="#Keyboard_IDs">Keyboard IDs</a><ul>
<li>  9.1 <a href="#Principles_for_Keyboard_Ids">Principles for Keyboard Ids</a></li>
</ul>
</li>
<li>  10 <a href="#Platform_Behaviors_in_Edge_Cases">Platform Behaviors in Edge Cases</a></li>
</ul><p><a name="Keyboards"></a></p><h2 id="1-keyboards">1 <a name="Introduction" href="#Introduction">Keyboards</a></h2><p>The CLDR keyboard format provides for the communication of keyboard mapping data between different modules, and the comparison of data across different vendors and platforms. The standardized identifier for keyboards can be used to communicate, internally or externally, a request for a particular keyboard mapping that is to be used to transform either text or keystrokes. The corresponding data can then be used to perform the requested actions.</p><p>For example, a web-based virtual keyboard may transform text in the following way. Suppose the user types a key that produces a "W" on a qwerty keyboard. A web-based tool using an azerty virtual keyboard can map that text ("W") to the text that would have resulted from typing a key on an azerty keyboard, by transforming "W" to "Z". Such transforms are in fact performed in existing web applications.</p><p>The data can also be used in analysis of the capabilities of different keyboards. It also allows better interoperability by making it easier for keyboard designers to see which characters are generally supported on keyboards for given languages.</p><p>To illustrate this specification, here is an abridged layout representing the English US 101 keyboard on the Mac OSX operating system (with an inserted long-press example). For more complete examples, and information collected about keyboards, see keyboard data in XML.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"en-t-k0-osx"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">platform</span>=<span class="hljs-string">"10.4"</span> <span class="hljs-attr">number</span>=<span class="hljs-string">"$Revision: 8294 $"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"U.S."</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E00"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"1"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"w"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D03"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"e"</span> <span class="hljs-attr">longPress</span>=<span class="hljs-string">"é è ê ë"</span> /&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"caps"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E00"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"1"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"W"</span> /&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"opt"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E00"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"¡"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=1 --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"œ"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=Q --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"∑"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=W --&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"` "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"à"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"À"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´ "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"´"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"á"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Á"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"˜ "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"˜"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"˜a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"ã"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"˜A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Ã"</span> /&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>And its associated platform file (which includes the hardware mapping):</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">platform</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"osx"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hardwareMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C02"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"6"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B01"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"7"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B02"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"12"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"13"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"18"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E01"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"50"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E00"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">hardwareMap</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">platform</span>&gt;</span>
</code></pre><hr><h2 id="2-goals-and-non-goals">2 <a name="Goals_and_Nongoals" href="#Goals_and_Nongoals">Goals and Non-goals</a></h2><p>Some goals of this format are:</p><ol>
<li>Make the XML as readable as possible.</li>
<li>Represent faithfully keyboard data from major platforms: it should be possible to create a functionally-equivalent data file (such that given any input, it can produce the same output).</li>
<li>Make as much commonality in the data across platforms as possible to make comparison easy.</li>
</ol><p>Some non-goals (outside the scope of the format) currently are:</p><ol>
<li>Display names or symbols for keycaps (eg, the German name for "Return"). If that were added to LDML, it would be in a different structure, outside the scope of this section.</li>
<li>Advanced IME features, handwriting recognition, etc.</li>
<li>Roundtrip mappings—the ability to recover precisely the same format as an original platform's representation. In particular, the internal structure may have no relation to the internal structure of external keyboard source data, the only goal is functional equivalence.</li>
</ol><p>Note: During development of this section, it was considered whether the modifier RAlt (=AltGr) should be merged with Option. In the end, they were kept separate, but for comparison across platforms implementers may choose to unify them.</p><p>Note that in parts of this document, the format <code>@x</code> is used to indicate the <em>attribute</em> <strong>x</strong>.</p><hr><h2 id="3-definitions">3 <a name="Definitions" href="#Definitions">Definitions</a></h2><p><strong>Arrangement</strong> is the term used to describe the relative position of the rectangles that represent keys, either physically or virtually. A physical keyboard has a static arrangement while a virtual keyboard may have a dynamic arrangement that changes per language and/or layer. While the arrangement of keys on a keyboard may be fixed, the mapping of those keys may vary.</p><p><strong>Base character:</strong> The character emitted by a particular key when no modifiers are active. In ISO terms, this is group 1, level 1.</p><p><strong>Base map:</strong> A mapping from the ISO positions to the base characters. There is only one base map per layout. The characters on this map can be output by not using any modifier keys.</p><p><strong>Core keyboard layout:</strong> also known as “alpha” block. The primary set of key values on a keyboard that are used for typing the target language of the keyboard. For example, the three rows of letters on a standard US QWERTY keyboard (QWERTYUIOP, ASDFGHJKL, ZXCVBNM) together with the most significant punctuation keys. Usually this equates to the minimal keyset for a language as seen on mobile phone keyboards.</p><p><strong>Hardware map:</strong> A mapping between key codes and ISO layout positions.</p><p><strong>Input Method Editor (IME):</strong> a component or program that supports input of large character sets. Typically, IMEs employ contextual logic and candidate UI to identify the Unicode characters intended by the user.</p><p><strong>ISO position:</strong> The corresponding position of a key using the ISO layout convention where rows are identified by letters and columns are identified by numbers. For example, "D01" corresponds to the "Q" key on a US keyboard. For the purposes of this document, an ISO layout position is depicted by a one-letter row identifier followed by a two digit column number (like "B03", "E12" or "C00"). The following diagram depicts a typical US keyboard layout superimposed with the ISO layout indicators (it is important to note that the number of keys and their physical placement relative to each-other in this diagram is irrelevant, rather what is important is their logical placement using the ISO convention):</p><p><img src="images/keyPositions.png" alt="keyboard layout example showing ISO key numbering"></p><p>One may also extend the notion of the ISO layout to support keys that don't map directly to the diagram above (such as the Android device - see diagram). Per the ISO standard, the space bar is mapped to "A03", so the period and comma keys are mapped to "A02" and "A04" respectively based on their relative position to the space bar. Also note that the "E" row does not exist on the Android keyboard.</p><p><img src="images/androidKeyboard.png" alt="keyboard layout example showing extension of ISO key numbering"></p><p>If it becomes necessary in the future, the format could extend the ISO layout to support keys that are located to the left of the "00" column by using negative column numbers "-01", "-02" and so on, or 100's complement "99", "98",...</p><p><strong>Key:</strong> A key on a physical keyboard.</p><p><strong>Key code:</strong> The integer code sent to the application on pressing a key.</p><p><strong>Key map:</strong> The basic mapping between ISO positions and the output characters for each set of modifier combinations associated with a particular layout. There may be multiple key maps for each layout.</p><p><strong>Keyboard:</strong> The physical keyboard.</p><p><strong>Keyboard layout:</strong> A layout is the overall keyboard configuration for a particular locale. Within a keyboard layout, there is a single base map, one or more key maps and zero or more transforms.</p><p><strong>Layer</strong> is an arrangement of keys on a virtual keyboard. Since it is often not intended to use two hands on a visual keyboard to allow the pressing of modifier keys. Modifier keys are made sticky in that one presses one, the visual representation, and even arrangement, of the keys change, and you press the key. This visual representation is a layer. Thus a virtual keyboard is made up of a set of layers.</p><p><strong>Long-press key:</strong> also known as a “child key”. A secondary key that is invoked from a top level key on a software keyboard. Secondary keys typically provide access to variants of the top level key, such as accented variants (a =&gt; á, à, ä, ã)</p><p><strong>Modifier:</strong> A key that is held to change the behavior of a keyboard. For example, the "Shift" key allows access to upper-case characters on a US keyboard. Other modifier keys include but is not limited to: Ctrl, Alt, Option, Command and Caps Lock.</p><p><strong>Physical keyboard</strong> is a keyboard that has individual keys that are pressed. Each key has a unique identifier and the arrangement doesn't change, even if the mapping of those keys does.</p><p><strong>Transform:</strong> A transform is an element that specifies a set of conversions from sequences of code points into one (or more) other code points. For example, in most latin keyboards hitting the "^" dead-key followed by the "e" key produces "ê".</p><p><strong>Virtual keyboard</strong> is a keyboard that is rendered on a, typically, touch surface. It has a dynamic arrangement and contrasts with a physical keyboard. This term has many synonyms: touch keyboard, software keyboard, SIP (Software Input Panel). This contrasts with other uses of the term virtual keyboard as an on-screen keyboard for reference or accessibility data entry.</p><h3 id="31-escaping">3.1 <a name="Escaping" href="#Escaping">Escaping</a></h3><p>When explicitly specified, attributes can contain escaped characters. This specification uses two methods of escaping, the <em>UnicodeSet</em> notation and the <code>\u{...}</code> notation.</p><p>The <em>UnicodeSet</em> notation is described in <a href="tr35.html#Unicode_Sets">UTS#35 section 5.3.3</a> and allows for comprehensive character matching, including by character range, properties, names, or codepoints. Currently, the following attributes allow <em>UnicodeSet</em> notation:</p><ul>
<li><code>from</code>, <code>before</code>, <code>after</code> on the <code>&lt;transform&gt;</code> element</li>
<li><code>from</code>, <code>before</code>, <code>after</code> on the <code>&lt;reorder&gt;</code> element</li>
<li><code>from</code>, <code>before</code>, <code>after</code> on the <code>&lt;backspace&gt;</code> element</li>
</ul><p>The <code>\u{...}</code> notation, a subset of hex notation, is described in <a href="http://www.unicode.org/reports/tr18/#Hex_notation">UTS#18 section 1.1</a>. It can refer to one or multiple individual codepoints. Currently, the following attributes allow the <code>\u{...}</code> notation:</p><ul>
<li><code>to</code>, <code>longPress</code>, <code>multitap</code>, <code>hint</code> on the <code>&lt;map&gt;</code> element</li>
<li><code>to</code> on the <code>&lt;transform&gt;</code> element</li>
<li><code>to</code> on the <code>&lt;backspace&gt;</code> element</li>
</ul><p>Characters of general category of Combining Mark (M), Control characters (Cc), Format characters (Cf), and whitespace other than space should be encoded using one of the notation above as appropriate.</p><hr><h2 id="4-file-and-directory-structure">4 <a name="File_and_Dir_Structure" href="#File_and_Dir_Structure">File and Directory Structure</a></h2><p>Each platform has its own directory, where a "platform" is a designation for a set of keyboards available from a particular source, such as Windows or ChromeOS. This directory name is the platform name (see Table 2 located further in the document). Within this directory there are two types of files:</p><ol>
<li>A single platform file (see XML structure for Platform file), this file includes a mapping of hardware key codes to the ISO layout positions. This file is also open to expansion for any configuration elements that are valid across the whole platform and that are not layout specific. This file is simply called <code>_platform.xml</code>.</li>
<li>Multiple layout files named by their locale identifiers. (eg. <code>lt-t-k0-chromeos.xml</code> or <code>ne-t-k0-windows.xml</code>).</li>
</ol><p>Keyboard data that is not supported on a given platform, but intended for use with that platform, may be added to the directory <code>/und/</code>. For example, there could be a file <code>/und/lt-t-k0-chromeos.xml</code>, where the data is intended for use with ChromeOS, but does not reflect data that is distributed as part of a standard ChromeOS release.</p><hr><h2 id="5-element-hierarchy---layout-file">5 <a name="Element_Heirarchy_Layout_File" href="#Element_Heirarchy_Layout_File">Element Hierarchy - Layout File</a></h2><h3 id="51-element-keyboard">5.1 <a name="Element_Keyboard" href="#Element_Keyboard">Element: keyboard</a></h3><p>This is the top level element. All other elements defined below are under this element.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"{locale ID}"</span>&gt;</span>
    {definition of the layout as described by the elements defined below}
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <em>none</em>
Children: <a href="#Element_version">version</a>, <a href="#Element_generation"><del>generation</del></a>, <a href="#Element_info">info</a>, <a href="#Element_names">names</a>, <a href="#Element_settings">settings</a>, <a href="#Element_import">import</a>, <a href="#Element_KeyMap">keyMap</a>, <a href="#Element_DisplayMap">displayMap</a>, <a href="#Element_layer">layer</a>, <a href="#Element_vkeys">vkeys</a>, <a href="#Element_transforms">transforms</a>, <a href="#Element_reorder">reorders</a>, <a href="#Element_backspaces">backspaces</a>
Occurence: required, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>locale</code> (required)</p><p>This mandatory attribute represents the locale of the keyboard using Unicode locale identifiers (see <a href="tr35.html">LDML</a>) - for example <code>"el"</code> for Greek. Sometimes, the locale may not specify the base language. For example, a Devanagari keyboard for many languages could be specified by BCP-47 code: <code>"und-Deva"</code>. For details, see <a href="#Keyboard_IDs">Keyboard IDs</a> .</p><p><strong>Example</strong> (for illustrative purposes only, not indicative of the real data)</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"ka-t-k0-qwerty-windows"</span>&gt;</span>
  …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"fr-CH-t-k0-android"</span>&gt;</span>
  …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="52-element-version">5.2 <a name="Element_version" href="#Element_version">Element: version</a></h3><p>Element used to keep track of the source data version.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">platform</span>=<span class="hljs-string">".."</span> <span class="hljs-attr">number</span>=<span class="hljs-string">".."</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <em>none</em>
Occurence: required, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>platform</code> (required)</p><blockquote>
<p>The platform source version. Specifies what version of the platform the data is from. For example, data from Mac OSX 10.4 would be specified as <code>platform="10.4"</code>. For platforms that have unstable version numbers which change frequently (like Linux), this field is set to an integer representing the iteration of the data starting with <code>"1"</code>. This number would only increase if there were any significant changes in the keyboard data.</p>
</blockquote><p><em>Attribute:</em> <code>number</code> (required)</p><blockquote>
<p>The data revision version. The attribute value must start with <code>$Revision</code> and end with <code>$</code>.</p>
</blockquote><p><em>Attribute:</em> <code>cldrVersion</code> (fixed by DTD)</p><blockquote>
<p>The CLDR specification version that is associated with this data file. This value is fixed and is inherited from the <a href="https://github.com/unicode-org/cldr/tree/main/keyboards/dtd">DTD file</a> and therefore does not show up directly in the XML file.</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"..-osx"</span>&gt;</span>
    …
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">platform</span>=<span class="hljs-string">"10.4"</span> <span class="hljs-attr">number</span>=<span class="hljs-string">"1"</span>/&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="53-element-generation">5.3 <del><a name="Element_generation" href="#Element_generation">Element: generation</a></del></h3><p>The <code>generation</code> element is now deprecated. It was used to keep track of the generation date of the data.</p><hr><h3 id="54-element-info">5.4 <a name="Element_info" href="#Element_info">Element: info</a></h3><p>Element containing informative properties about the layout, for displaying in user interfaces etc.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">info</span> [<span class="hljs-attr">author</span>=<span class="hljs-string">"{author}"</span>]
      [<span class="hljs-attr">normalization</span>=<span class="hljs-string">"{form}"</span>]
      [<span class="hljs-attr">layout</span>=<span class="hljs-string">"{hint of the layout}"</span>]
      [<span class="hljs-attr">indicator</span>=<span class="hljs-string">"{short identifier}"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <em>none</em>
Occurence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>author</code> (optional)</p><blockquote>
<p>The <code>author</code> attribute contains the name of the author of the layout file.</p>
</blockquote><p><em>Attribute:</em> <code>normalization</code> (optional)</p><blockquote>
<p>The <code>normalization</code> attribute describes the intended normalization form of the keyboard layout output. The valid values are <code>NFC</code>, <code>NFD</code> or <code>other</code>.
An example use case is aiding user to choose among the two same layouts with one outputting characters in the normalization form C and one in the normalization form D.</p>
</blockquote><p><em>Attribute:</em> <code>layout</code> (optional)</p><blockquote>
<p>The <code>layout</code> attribtue describes the layout pattern, such as QWERTY, DVORAK, INSCRIPT, etc. typically used to distinguish various layouts for the same language.</p>
</blockquote><p><em>Attribute:</em> <code>indicator</code> (optional)</p><blockquote>
<p>The <code>indicator</code> attribute describes a short string to be used in currently selected layout indicator, such as US, SI9 etc.
Typically, this is shown on a UI element that allows switching keyboard layouts and/or input languages.</p>
</blockquote><hr><h3 id="55-element-names">5.5 <a name="Element_names" href="#Element_names">Element: names</a></h3><p>Element used to store any names given to the layout by the platform.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>
    {set of name elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_name">name</a>
Occurence: required, single</p>
</small>
</blockquote><h3 id="56-element-name">5.6 <a name="Element_name" href="#Element_name">Element: name</a></h3><p>A single name given to the layout by the platform.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".."</span>&gt;</span>
</code></pre><blockquote>
<small>

</small><p><small>Parents: <a href="#Element_names">names</a>
Children: <em>none</em>
Occurence: required, multiple
</small></p>
</blockquote><p><em>Attribute:</em> <code>value</code> (required)</p><blockquote>
<p>The name of the layout.</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"bg-t-k0-windows-phonetic-trad"</span>&gt;</span>
    …
    <span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Bulgarian (Phonetic Traditional)"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="57-element-settings">5.7 <a name="Element_settings" href="#Element_settings">Element: settings</a></h3><p>An element used to keep track of layout specific settings. This element may or may not show up on a layout. These settings reflect the normal practice on the platform. However, an implementation using the data may customize the behavior. For example, for <code>transformFailure</code> the implementation could ignore the setting, or modify the text buffer in some other way (such as by emitting backspaces).</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> [<span class="hljs-attr">fallback</span>=<span class="hljs-string">"omit"</span>] [<span class="hljs-attr">transformFailure</span>=<span class="hljs-string">"omit"</span>] [<span class="hljs-attr">transformPartial</span>=<span class="hljs-string">"hide"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <em>none</em>
Occurence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>fallback="omit"</code> (optional)</p><blockquote>
<p>The presence of this attribute means that when a modifier key combination goes unmatched, no output is produced. The default behavior (when this attribute is not present) is to fallback to the base map when the modifier key combination goes unmatched.</p>
</blockquote><p>If this attribute is present, it must have a value of omit.</p><p><em>Attribute:</em> <code>transformFailure="omit"</code> (optional)</p><blockquote>
<p>This attribute describes the behavior of a transform when it is escaped (see the <code>transform</code> element in the Layout file for more information). A transform is escaped when it can no longer continue due to the entry of an invalid key. For example, suppose the following set of transforms are valid:</p>
<p>^e → ê</p>
<p>^a → â</p>
</blockquote><p>Suppose a user now enters the "^" key then "^" is now stored in a buffer and may or may not be shown to the user (see the <code>partial</code> attribute).</p><p>If a user now enters d, then the transform has failed and there are two options for output.</p><ol>
<li><p>default behavior - "^d"</p>
</li>
<li><p>omit - "" (nothing and the buffer is cleared)</p>
</li>
</ol><p>The default behavior (when this attribute is not present) is to emit the contents of the buffer upon failure of a transform.</p><p>If this attribute is present, it must have a value of omit.</p><p><em>Attribute:</em> <code>transformPartial="hide"</code> (optional)</p><blockquote>
<p>This attribute describes the behavior the system while in a transform. When this attribute is present then don't show the values of the buffer as the user is typing a transform (this behavior can be seen on Windows or Linux platforms).</p>
</blockquote><p>By default (when this attribute is not present), show the values of the buffer as the user is typing a transform (this behavior can be seen on the Mac OSX platform).</p><p>If this attribute is present, it must have a value of hide.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"bg-t-k0-windows-phonetic-trad"</span>&gt;</span>
    …
    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"omit"</span> <span class="hljs-attr">transformPartial</span>=<span class="hljs-string">"hide"</span> /&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>Indicates that:</p><ol>
<li> When a modifier combination goes unmatched, do not output anything when a key is pressed.</li>
<li> If a transform is escaped, output the contents of the buffer.</li>
<li> During a transform, hide the contents of the buffer as the user is typing.</li>
</ol><hr><h3 id="58-element-keymap">5.8 <a name="Element_keyMap" href="#Element_keyMap">Element: keyMap</a></h3><p>This element defines the group of mappings for all the keys that use the same set of modifier keys. It contains one or more map elements.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> [<span class="hljs-attr">modifiers</span>=<span class="hljs-string">"{Set of Modifier Combinations}"</span>]&gt;</span>
    {a set of map elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_map">map</a>, <a href="#Element_flicks">flicks</a>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>modifiers</code> (optional)</p><blockquote>
<p>A set of modifier combinations that cause this key map to be "active". Each combination is separated by a space. The interpretation is that there is a match if any of the combinations match, that is, they are ORed. Therefore, the order of the combinations within this attribute does not matter.</p>
</blockquote><blockquote>
<p>A combination is simply a concatenation of words to represent the simultaneous activation of one or more modifier keys. The order of the modifier keys within a combination does not matter, although don't care cases are generally added to the end of the string for readability (see next paragraph). For example: <code>"cmd+caps"</code> represents the Caps Lock and Command modifier key combination. Some keys have right or left variant keys, specified by a 'R' or 'L' suffix. For example: <code>"ctrlR+caps"</code> would represent the Right-Control and Caps Lock combination. For simplicity, the presence of a modifier without a 'R' or 'L' suffix means that either its left or right variants are valid. So <code>"ctrl+caps"</code> represents the same as <code>"ctrlL+ctrlR?+caps ctrlL?+ctrlR+caps"</code>.</p>
</blockquote><p>A modifier key may be further specified to be in a "don't care" state using the '?' suffix. The "don't care" state simply means that the preceding modifier key may be either ON or OFF. For example <code>"ctrl+shift?"</code> could be expanded into <code>"ctrl ctrl+shift"</code>.</p><p>Within a combination, the presence of a modifier WITHOUT the '?' suffix indicates this key MUST be on. The converse is also true, the absence of a modifier key means it MUST be off for the combination to be active.</p><p>Here is an exhaustive list of all possible modifier keys:</p><h5 id="possible-modifier-keys"><a name="Possible_Modifier_Keys" href="#Possible_Modifier_Keys">Possible Modifier Keys</a></h5><table>
<thead>
<tr>
<th>Modifier Keys</th>
<th></th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td><code>altL</code></td>
<td><code>altR</code></td>
<td>xAlty → xAltR+AltL? xAltR?AltLy</td>
</tr>
<tr>
<td><code>ctrlL</code></td>
<td><code>ctrlR</code></td>
<td>ditto for Ctrl</td>
</tr>
<tr>
<td><code>shiftL</code></td>
<td><code>shiftR</code></td>
<td>ditto for Shift</td>
</tr>
<tr>
<td><code>optL</code></td>
<td><code>optR</code></td>
<td>ditto for Opt</td>
</tr>
<tr>
<td><code>caps</code></td>
<td></td>
<td>Caps Lock</td>
</tr>
<tr>
<td><code>cmd</code></td>
<td></td>
<td>Command on the Mac</td>
</tr>
</tbody></table><p>All sets of modifier combinations within a layout are disjoint with no-overlap existing between the key maps. That is, for every possible modifier combination, there is at most a single match within the layout file. There are thus never multiple matches. If no exact match is available, the match falls back to the base map unless the <code>fallback="omit"</code> attribute in the <code>settings</code> element is set, in which case there would be no output at all.</p><p><strong>Example</strong></p><p>To illustrate, the following example produces an invalid layout because pressing the "Ctrl" modifier key produces an indeterminate result:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"ctrl+shift?"</span>&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"ctrl"</span>&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
</code></pre><p>Modifier Examples:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"cmd?+opt+caps?+shift"</span> /&gt;</span>
</code></pre><p>Caps-Lock may be ON or OFF, Option must be ON, Shift must be ON and Command may be ON or OFF.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"shift caps"</span> /&gt;</span>
</code></pre><p>Caps-Lock must be ON OR Shift must be ON.</p><p>If the <code>modifiers</code> attribute is not present on a <code>keyMap</code> then that particular key map is the base map.</p><hr><h3 id="59-element-map">5.9 <a name="Element_map" href="#Element_map">Element: map</a></h3><p>This element defines a mapping between the base character and the output for a particular set of active modifier keys. This element must have the <code>keyMap</code> element as its parent.</p><p>If a <code>map</code> element for a particular ISO layout position has not been defined then if this key is pressed, no output is produced.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">map</span>
 <span class="hljs-attr">iso</span>=<span class="hljs-string">"{the iso position}"</span>
 <span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span>
 [<span class="hljs-attr">longPress</span>=<span class="hljs-string">"{long press keys}"</span>]
 [<span class="hljs-attr">transform</span>=<span class="hljs-string">"no"</span>]
 [<span class="hljs-attr">multitap</span>=<span class="hljs-string">"{the output on subsequent taps}"</span>]
 [<span class="hljs-attr">longPress-status</span>=<span class="hljs-string">"optional"</span>]
 [<span class="hljs-attr">optional</span>=<span class="hljs-string">"{optional mappings}"</span>]
 [<span class="hljs-attr">hint</span>=<span class="hljs-string">"{hint to long press content}"</span>]
 /&gt;</span><span class="hljs-comment">&lt;!-- {Comment to improve readability (if needed)} --&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyMap">keyMap</a>
Children: <em>none</em>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>iso</code> (exactly one of base and iso is required)</p><blockquote>
<p>The <code>iso</code> attribute represents the ISO layout position of the key (see the definition at the beginning of the document for more information).</p>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>The <code>to</code> attribute contains the output sequence of characters that is emitted when pressing this particular key. Control characters, whitespace (other than the regular space character) and combining marks in this attribute are escaped using the <code>\u{...}</code> notation.</p>
</blockquote><p><em>Attribute:</em> <code>longPress="optional"</code> (optional)</p><blockquote>
<p>The <code>longPress</code> attribute contains any characters that can be emitted by "long-pressing" a key, this feature is prominent in mobile devices. The possible sequences of characters that can be emitted are whitespace delimited. Control characters, combining marks and whitespace (which is intended to be a long-press option) in this attribute are escaped using the <code>\u{...}</code> notation.</p>
</blockquote><p><em>Attribute:</em> <code>transform="no"</code> (optional)</p><blockquote>
<p>The <code>transform</code> attribute is used to define a key that never participates in a transform but its output shows up as part of a transform. This attribute is necessary because two different keys could output the same characters (with different keys or modifier combinations) but only one of them is intended to be a dead-key and participate in a transform. This attribute value must be no if it is present.</p>
</blockquote><p><em>Attribute:</em> <code>multitap</code> (optional)</p><blockquote>
<p>A space-delimited list of strings, where each successive element of the list is produced by the corresponding number of quick taps. For example, three taps on the key C01 will produce a “c” in the following example (first tap produces “a”, two taps produce “bb” etc.).</p>
<p><em>Example:</em></p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">multitap</span>=<span class="hljs-string">"bb c d"</span>&gt;</span>
</code></pre>
<p>Control characters, combining marks and whitespace (which is intended to be a multitap option) in this attribute are escaped using the <code>\u{...}</code> notation.</p>
</blockquote><p><em>Attribute:</em> <code>longPress-status</code> (optional)</p><blockquote>
<p>Indicates optional <code>longPress</code> values. Must only occur with a <code>longPress</code> value. May be suppressed or shown, depending on user settings. There can be two <code>map</code> elements that differ only by <code>longPress-status</code>, allowing two different sets of <code>longPress</code> values.</p>
<p><em>Example:</em></p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">longPress</span>=<span class="hljs-string">"à â % æ á ä ã å ā ª"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">longPress</span>=<span class="hljs-string">"à â á ä ã å ā"</span> <span class="hljs-attr">longPress-status</span>=<span class="hljs-string">"optional"</span> /&gt;</span>
</code></pre>
</blockquote><p><em>Attribute:</em> <code>optional</code> (optional)</p><blockquote>
<p>Indicates optional mappings. May be suppressed or shown, depending on user settings.</p>
</blockquote><p><em>Attribute:</em> <code>hint</code> (optional)</p><blockquote>
<p>Indicates a hint as to long-press contents, such as the first character of the <code>longPress</code> value, that can be displayed on the key. May be suppressed or shown, depending on user Settings. Characters in this attribute can be escaped using the <code>\u{...}</code> notation.</p>
<p><em>Example:</em> where the hint is "{":</p>
<p><img src="images/keycapHint.png" alt="keycap hint"></p>
</blockquote><p>For example, suppose there are the following keys, their output and one transform:</p><pre><code>E00 outputs `
Option+E00 outputs ` (the dead-version which participates in transforms).
`e → è
</code></pre><p>Then the first key must be tagged with <code>transform="no"</code> to indicate that it should never participate in a transform.</p><p>Comment: US key equivalent, base key, escaped output and escaped longpress</p><p>In the generated files, a comment is included to help the readability of the document. This comment simply shows the English key equivalent (with prefix <code>key=</code>), the base character (<code>base=</code>), the escaped output (<code>to=</code>) and escaped long-press keys (<code>long=</code>). These comments have been inserted strategically in places to improve readability. Not all comments include all components since some of them may be obvious.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"fr-BE-t-k0-windows"</span>&gt;</span>
    …
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"shift"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"A"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=Q --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Z"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=W --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D03"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"E"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D04"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"R"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D05"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"T"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D06"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Y"</span> /&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
     …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"ps-t-k0-windows"</span>&gt;</span>
    …
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">'altR+caps? ctrl+alt+caps?'</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D04"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u{200e}"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=R base=ق --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D05"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u{200f}"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=T base=ف --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D08"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u{670}"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- key=I base=ه to= ٰ --&gt;</span>
        …
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    …
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h4 id="591-elements-flicks-flick">5.9.1 <a name="Element_flicks" href="#Element_flicks">Elements: flicks, flick</a></h4><p>The <code>flicks</code> element is used to generate results from a "flick" of the finger on a mobile device.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"{the iso position}"</span>&gt;</span>
    {a set of flick elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">flicks</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyMap">keyMap</a>
Children: <a href="#Element_flicks">flick</a>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>iso</code> (required)</p><blockquote>
<p>The <code>iso</code> attribute represents the ISO layout position of the key (see the definition at the beginning of the document for more information).</p>
</blockquote><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">flick</span> <span class="hljs-attr">directions</span>=<span class="hljs-string">"{list of directions}"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_flicks">flicks</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>directions</code> (required)</p><blockquote>
<p>The <code>directions</code> attribute value is a space-delimited list of keywords, that describe a path, currently restricted to the cardinal and intercardinal directions <code>{n e s w ne nw se sw}</code>.</p>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>The to attribute value is the result of (one or more) flicks.</p>
</blockquote><p><strong>Example</strong>
where a flick to the Northeast then South produces two code points.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">flick</span> <span class="hljs-attr">directions</span>=<span class="hljs-string">"ne s"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\uABCD\uDCBA"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">flicks</span>&gt;</span>
</code></pre><hr><h3 id="510-element-import">5.10 <a name="Element_import" href="#Element_import">Element: import</a></h3><p>The <code>import</code> element references another file of the same type and includes all the subelements of the top level element as though the <code>import</code> element were being replaced by those elements, in the appropriate section of the XML file. For example:</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"standard_transforms.xml"</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <em>none</em>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>path</code> (required)</p><blockquote>
<p>The value is contains a relative path to the included ldml file. There is a standard set of directories to be searched that an application may provide. This set is always prepended with the directory in which the current file being read, is stored.</p>
</blockquote><p>If two identical elements, as described below, are defined, the later element will take precedence. Thus if a <code>hardwareMap/map</code> for the same keycode on the same page is defined twice (for example once in an included file), the later one will be the resulting mapping.</p><p>Elements are considered to have three attributes that make them unique: the tag of the element, the parent and the identifying attribute. The parent in its turn is a unique element and so on up the chain. If the distinguishing attribute is optional, its non-existence is represented with an empty value. Here is a list of elements and their defining attributes. If an element is not listed then if it is a leaf element, only one occurs and it is merely replaced. If it has children, then the subelements are considered, in effect merging the element in question.</p><table>
<thead>
<tr>
<th>Element</th>
<th>Parent</th>
<th>Distinguishing attribute</th>
</tr>
</thead>
<tbody><tr>
<td><code>import</code></td>
<td><code>keyboard</code></td>
<td><code>@path</code></td>
</tr>
<tr>
<td><code>keyMap</code></td>
<td><code>keyboard</code></td>
<td><code>@modifiers</code></td>
</tr>
<tr>
<td><code>map</code></td>
<td><code>keyMap</code></td>
<td><code>@iso</code></td>
</tr>
<tr>
<td><code>flicks</code></td>
<td><code>keyMap</code></td>
<td><code>@iso</code></td>
</tr>
<tr>
<td><code>flick</code></td>
<td><code>flicks</code></td>
<td><code>@directions</code></td>
</tr>
<tr>
<td><code>display</code></td>
<td><code>displayMap</code></td>
<td><code>@to</code></td>
</tr>
<tr>
<td><code>layer</code></td>
<td><code>keyboard</code></td>
<td><code>@modifier</code></td>
</tr>
<tr>
<td><code>row</code></td>
<td><code>layer</code></td>
<td><code>@keys</code></td>
</tr>
<tr>
<td><code>switch</code></td>
<td><code>layer</code></td>
<td><code>@iso</code></td>
</tr>
<tr>
<td><code>vkeys</code></td>
<td><code>layer</code></td>
<td><code>@iso</code></td>
</tr>
<tr>
<td><code>transforms</code></td>
<td><code>keyboard</code></td>
<td><code>@type</code></td>
</tr>
<tr>
<td><code>transform</code></td>
<td><code>keyboard</code></td>
<td><code>@before</code>, <code>@from</code>, <code>@after</code></td>
</tr>
<tr>
<td><code>reorder</code></td>
<td><code>reorders</code></td>
<td><code>@before</code>, <code>@from</code>, <code>@after</code></td>
</tr>
<tr>
<td><code>backspace</code></td>
<td><code>backspaces</code></td>
<td><code>@before</code>, <code>@from</code>, <code>@after</code></td>
</tr>
</tbody></table><p>In order to help identify mistakes, it is an error if a file contains two elements that override each other. All element overrides must come as a result of an <code>&lt;include&gt;</code> element either for the element overridden or the element overriding.</p><p>The following elements are not imported from the source file:</p><ul>
<li><code>version</code></li>
<li><code>generation</code></li>
<li><code>names</code></li>
<li><code>settings</code></li>
</ul><hr><h3 id="511-element-displaymap">5.11 <a name="Element_displayMap" href="#Element_displayMap">Element: displayMap</a></h3><p>The displayMap can be used to describe what is to be displayed on the keytops for various keys. For the most part, such explicit information is unnecessary since the <code>@to</code> element from the <code>keyMap/map</code> element can be used. But there are some characters, such as diacritics, that do not display well on their own and so explicit overrides for such characters can help. The <code>displayMap</code> consists of a list of display subelements.</p><p>DisplayMaps are designed to be shared across many different keyboard layout descriptions, and included in where needed.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">displayMap</span>&gt;</span>
    {a set of display elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">displayMap</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_display">display</a>
Occurence: optional, single</p>
</small>
</blockquote><hr><h3 id="512-element-display">5.12 <a name="Element_display" href="#Element_display">Element: display</a></h3><p>The <code>display</code> element describes how a character, that has come from a <code>keyMap/map</code> element, should be displayed on a keyboard layout where such display is possible.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"{show as}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_displayMap">displayMap</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>Specifies the character or character sequence from the <code>keyMap/map</code> element that is to have a special display.</p>
</blockquote><p><em>Attribute:</em> <code>display</code> (required)</p><blockquote>
<p>Required and specifies the character sequence that should be displayed on the keytop for any key that generates the <code>@to</code> sequence. (It is an error if the value of the <code>display</code> attribute is the same as the value of the <code>to</code> attribute.)</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">longpress</span>=<span class="hljs-string">"\u0301 \u0300"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displayMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u0300"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"\u02CB"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u0301"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"\u02CA"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">displayMap</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>To allow <code>displayMap</code>s to be shared across descriptions, there is no requirement that <code>@to</code> in a <code>display</code> element matches any <code>@to</code> in any <code>keyMap/map</code> element in the keyboard description.</p><hr><h3 id="513-element-layer">5.13 <a name="Element_layer" href="#Element_layer">Element: layer</a></h3><p>A <code>layer</code> element describes the configuration of keys on a particular layer of a keyboard. It contains one or more <code>row</code> elements to describe which keys exist in each <code>row</code> and optionally one or more <code>switch</code> elements that describe how keys in the layer switch the layer to another. In addition, for platforms that require a mapping from a key to a virtual key (for example Windows or Mac) there is also an optional <code>vkeys</code> element to describe the mapping.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"{Set of Modifier Combinations}"</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_row">row</a>, <a href="#Element_switch">switch</a>, <a href="#Element_vkeys">vkeys</a>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>modifier</code> (required)</p><blockquote>
<p>This has two roles. It acts as an identifier for the <code>layer</code> element and also provides the linkage into a keyMap. A modifier is a single modifier combination such that it is matched by one of the modifier combinations in one of the <code>keyMap/@modifiers</code> attribute. To indicate that no modifiers apply the reserved name of "none" is used. For the purposes of fallback vkey mapping, the following modifier components are reserved: "shift", "ctrl", "alt", "caps", "cmd", "opt" along with the "L" and "R" optional single suffixes for the first 3 in that list. There must be a <code>keyMap</code> whose <code>@modifiers</code> attribute matches the <code>@modifier</code> attribute of the <code>layer</code> element. It is an error if there is no such <code>keyMap</code>.</p>
</blockquote><p>The <code>keymap/@modifier</code> often includes multiple combinations that match. It is not necessary (or prefered) to include all of these. Instead a minimal matching element should be used, such that exactly one keymap is matched.</p><p>The following are examples of situations where the <code>@modifiers</code> and <code>@modifier</code> do not match, with a different keymap definition than above.</p><table>
<thead>
<tr>
<th><code>keyMap/@modifiers</code></th>
<th><code>layer/@modifier</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>shiftL</code></td>
<td><code>shift</code> (ambiguous)</td>
</tr>
<tr>
<td><code>altR</code></td>
<td><code>alt</code></td>
</tr>
<tr>
<td><code>shiftL?+shiftR</code></td>
<td><code>shift</code></td>
</tr>
</tbody></table><p>And these do match:</p><table>
<thead>
<tr>
<th><code>keyMap/@modifiers</code></th>
<th><code>layer/@modifier</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>shiftL shiftR</code></td>
<td><code>shift</code></td>
</tr>
</tbody></table><p>The use of <code>@modifier</code> as an identifier for a layer, is sufficient since it is always unique among the set of <code>layer</code> elements in a keyboard.</p><hr><h3 id="514-element-row">5.14 <a name="Element_row" href="#Element_row">Element: row</a></h3><p>A <code>row</code> element describes the keys that are present in the row of a keyboard. <code>row</code> elements are ordered within a <code>layout</code> element with the top visual row being stored first.</p><p>The row element introduces the <code>keyId</code> which may be an <code>ISOKey</code> or a <code>specialKey</code>. More formally:</p><pre><code>keyId = ISOKey | specialKey
ISOKey = [A-Z][0-9][0-9]
specialKey = [a-z][a-zA-Z0-9]{2,7}
</code></pre><p>ISOKey denotes a key having an <a href="#Definitions">ISO Position</a>. SpecialKey is used to identify functional keys occurring on a virtual keyboard layout.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"{keyId}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_layer">layer</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>keys</code> (required)</p><blockquote>
<p>This is a string that lists the <code>keyId</code> for each of the keys in a row. Key ranges may be contracted to firstkey-lastkey but only for <code>ISOKey</code> type <code>keyId</code>s. The interpolation between the first and last keys names is entirely numeric. Thus <code>D00-D03</code> is equivalent to <code>D00 D01 D02 D03</code>. It is an error if the first and last keys do not have the same alphabetic prefix or the last key numeric component is less than or equal to the first key numeric component.</p>
</blockquote><p><code>specialKey</code> type <code>keyId</code>s may take any value within their syntactic constraint. But the following <code>specialKey</code>s are reserved to allow applications to identify them and give them special handling:</p><ul>
<li><code>"bksp"</code>, <code>"enter"</code>, <code>"space"</code>, <code>"tab"</code>, "<code>esc"</code>, <code>"sym"</code>, <code>"num"</code></li>
<li>all the reserved modifier names</li>
<li>specialKeys starting with the letter "x" for future reserved names.</li>
</ul><p><strong>Example</strong></p><p>Here is an example of a <code>row</code> element:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"none"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"D01-D10"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"C01-C09"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"shift B01-B07 bksp"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"sym A01 smilies A02-A03 enter"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
</code></pre><hr><h3 id="515-element-switch">5.15 <a name="Element_switch" href="#Element_switch">Element: switch</a></h3><p>The <code>switch</code> element describes a function key that has been included in the layout. It specifies which layer pressing the key switches you to and also what the key looks like.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">switch</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"{specialKey}"</span>
        <span class="hljs-attr">layer</span>=<span class="hljs-string">"{Set of Modifier Combinations}"</span>
        <span class="hljs-attr">display</span>=<span class="hljs-string">"{show as}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_layer">layer</a>
Children: <em>none</em>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>iso</code> (required)</p><blockquote>
<p>The <code>keyId</code> as specified in one of the <code>row</code> elements. This must be a <code>specialKey</code> and not an <code>ISOKey</code>.</p>
</blockquote><p><em>Attribute:</em> <code>layer</code> (required)</p><blockquote>
<p>The modifier attribute of the resulting <code>layer</code> element that describes the layer the user gets switched to.</p>
</blockquote><p><em>Attribute:</em> <code>display</code> (required)</p><blockquote>
<p>A string to be displayed on the key.</p>
</blockquote><p><strong>Example</strong></p><p>Here is an example of a <code>switch</code> element for a shift key:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"none"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"D01-D10"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"C01-C09"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"shift B01-B07 bksp"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"sym A01 smilies A02-A03 enter"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">switch</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"shift"</span> <span class="hljs-attr">layer</span>=<span class="hljs-string">"shift"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"<span class="hljs-symbol">&amp;#x21EA;</span>"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"shift"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"D01-D10"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"C01-C09"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"shift B01-B07 bksp"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"sym A01 smilies A02-A03 enter"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">switch</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"shift"</span> <span class="hljs-attr">layer</span>=<span class="hljs-string">"none"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"<span class="hljs-symbol">&amp;#x21EA;</span>"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
</code></pre><hr><h3 id="516-element-vkeys">5.16 <a name="Element_vkeys" href="#Element_vkeys">Element: vkeys</a></h3><p>On some architectures, applications may directly interact with keys before they are converted to characters. The keys are identified using a virtual key identifier or vkey. The mapping between a physical keyboard key and a vkey is keyboard-layout dependent. For example, a French keyboard would identify the D01 key as being an 'a' with a vkey of 'a' as opposed to 'q' on a US English keyboard. While vkeys are layout dependent, they are not modifier dependent. A shifted key always has the same vkey as its unshifted counterpart. In effect, a key is identified by its vkey and the modifiers active at the time the key was pressed.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span>&gt;</span>
    {a set of vkey elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_layer">layer</a>, <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_vkey">vkey</a>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>type</code></p><blockquote>
<p>Current values: android, chromeos, osx, und, windows.</p>
</blockquote><p>For a physical keyboard there is a layout specific default mapping of keys to vkeys. These are listed in a <code>vkeys</code> element which takes a list of <code>vkey</code> element mappings and is identified by a type. There are different vkey mappings required for different platforms. While <code>type="windows"</code> vkeys are very similar to <code>type="osx"</code> vkeys, they are not identical and require their own mapping.</p><p>The most common model for specifying vkeys is to import a standard mapping, say to the US layout, and then to add a <code>vkeys</code> element to change the mapping appropriately for the specific layout.</p><p>In addition to describing physical keyboards, vkeys also get used in virtual keyboards. Here the vkey mapping is local to a layer and therefore a <code>vkeys</code> element may occur within a <code>layout</code> element. In the case where a <code>layout</code> element has no <code>vkeys</code> element then the resulting mapping may either be empty (none of the keys represent keys that have vkey identifiers) or may fallback to the layout wide vkeys mapping. Fallback only occurs if the layout's <code>modifier</code> attribute consists only of standard modifiers as listed as being reserved in the description of the <code>layout/@modifier</code> attribute, and if the modifiers are standard for the platform involved. So for Windows, <code>"cmd"</code> is a reserved modifier but it is not standard for Windows. Therefore on Windows the vkey mapping for a layout with <code>@modifier="cmd" </code>would be empty.</p><p>A <code>vkeys</code> element consists of a list of <code>vkey</code> elements.</p><hr><h3 id="517-element-vkey">5.17 <a name="Element_vkey" href="#Element_vkey">Element: vkey</a></h3><p>A <code>vkey</code> element describes a mapping between a key and a vkey for a particular platform.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"{iso position}"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"{identifier}"</span>
      [<span class="hljs-attr">modifier</span>=<span class="hljs-string">"{Set of Modifier Combinations}"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_vkeys">vkeys</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>iso</code> (required)</p><blockquote>
<p>The ISOkey being mapped.</p>
</blockquote><p><em>Attribute:</em> <code>vkey</code> (required)</p><blockquote>
<p>The resultant vkey identifier (the value is platform specific).</p>
</blockquote><p><em>Attribute:</em> <code>modifier</code></p><blockquote>
<p>This attribute may only be used if the parent <code>vkeys</code> element is a child of a <code>layout</code> element. If present it allows an unmodified key from a layer to represent a modified virtual key.</p>
</blockquote><p><strong>Example</strong></p><p>This example shows some of the mappings for a French keyboard layout:</p><p> <em>shared/win-vkey.xml</em></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"windows"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_Q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_W"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_A"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_Z"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p><em>shared/win-fr.xml</em></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"shared/win-vkey.xml"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"z"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"w"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span> <span class="hljs-attr">modifiers</span>=<span class="hljs-string">"shift"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"A"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Z"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"W"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"windows"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_A"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_Z"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_Q"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"B01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_W"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>In the context of a virtual keyboard there might be a symbol layer with the following layout:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keyMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"1"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2"</span> /&gt;</span>
        ...
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D09"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"9"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D10"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"!"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C02"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"@"</span> /&gt;</span>
        ...
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C09"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"("</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C10"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">")"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keyMap</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"sym"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"D01-D10"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"C01-C09"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"shift B01-B07 bksp"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"sym A00-A03 enter"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">switch</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"sym"</span> <span class="hljs-attr">layer</span>=<span class="hljs-string">"none"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"ABC"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">switch</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"shift"</span> <span class="hljs-attr">layer</span>=<span class="hljs-string">"sym+shift"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"<span class="hljs-symbol">&amp;amp;</span>=/&lt;"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"windows"</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_1"</span> /&gt;</span>
            ...
            <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"D10"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_0"</span> /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C01"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_1"</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"shift"</span> /&gt;</span>
            ...
            <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"C10"</span> <span class="hljs-attr">vkey</span>=<span class="hljs-string">"VK_0"</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"shift"</span> /&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="518-element-transforms">5.18 <a name="Element_transforms" href="#Element_transforms">Element: transforms</a></h3><p>This element defines a group of one or more <code>transform</code> elements associated with this keyboard layout. This is used to support features such as dead-keys, character reordering, etc. using a straightforward structure that works for all the keyboards tested, and that results in readable source data.</p><p>There can be multiple <code>&lt;transforms&gt;</code> elements</p><p>Syntax</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"..."</span>&gt;</span>
    {a set of transform elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_transform">transform</a>
Occurence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>type</code> (required)</p><blockquote>
<p>Current values: <code>simple</code>, <code>final</code>.</p>
</blockquote><p>There are other keying behaviors that are needed particularly in handing complex orthographies from various parts of the world. The behaviors intended to be covered by the transforms are:</p><ul>
<li>Reordering combining marks. The order required for underlying storage may differ considerably from the desired typing order. In addition, a keyboard may want to allow for different typing orders.</li>
<li>Error indication. Sometimes a keyboard layout will want to specify to the application that a particular keying sequence in a context is in error and that the application should indicate that that particular keypress is erroneous.</li>
<li>Backspace handling. There are various approaches to handling the backspace key. An application may treat it as an undo of the last key input, or it may simply delete the last character in the currently output text, or it may use transform rules to tell it how much to delete.</li>
</ul><p>We consider each transform type in turn and consider attributes to the <code>&lt;transforms&gt;</code> element pertinent to that type.</p><hr><h3 id="519-element-transform">5.19 <a name="Element_transform" href="#Element_transform">Element: transform</a></h3><p>This element must have the <code>transforms</code> element as its parent. This element represents a single transform that may be performed using the keyboard layout. A transform is an element that specifies a set of conversions from sequences of code points into one (or more) other code points.. For example, in most French keyboards hitting the "^" dead-key followed by the "e" key produces "ê".</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{combination of characters}"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{output}"</span>
   [<span class="hljs-attr">before</span>=<span class="hljs-string">"{look-behind required match}"</span>]
   [<span class="hljs-attr">after</span>=<span class="hljs-string">"{look-ahead required match}"</span>]
   [<span class="hljs-attr">error</span>=<span class="hljs-string">"fail"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_transforms">transforms</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>from</code> (required)</p><blockquote>
<p>The <code>from</code> attribute consists of a sequence of elements. Each element matches one character and may consist of a codepoint or a UnicodeSet (both as defined in <a href="https://www.unicode.org/reports/tr35/#Unicode_Sets">UTS#35 section 5.3.3</a>).</p>
</blockquote><p>For example, suppose there are the following transforms:</p><pre><code>^e → ê
^a → â
^o → ô
</code></pre><p>If the user types a key that produces "^", the keyboard enters a dead state. When the user then types a key that produces an "e", the transform is invoked, and "ê" is output. Suppose a user presses keys producing "^" then "u". In this case, there is no match for the "^u", and the "^" is output if the <code>transformFailure</code> attribute in the <code>settings</code> element is set to emit. If there is no transform starting with "u", then it is also output (again only if <code>transformFailure</code> is set to emit) and the mechanism leaves the "dead" state.</p><p>The UI may show an initial sequence of matching characters with a special format, as is done with dead-keys on the Mac, and modify them as the transform completes. This behavior is specified in the <code>partial</code> attribute in the <code>transform</code> element.</p><p>Most transforms in practice have only a couple of characters. But for completeness, the behavior is defined on all strings. The following applies when no exact match exists:</p><ol>
<li>If there could be a longer match if the user were to type additional keys, go into a 'dead' state.</li>
<li>If there could not be a longer match, find the longest actual match, emit the transformed text (if <code>transformFailure</code> is set to emit), and start processing again with the remainder.</li>
<li>If there is no possible match, output the first character, and start processing again with the remainder.</li>
</ol><p>Suppose that there are the following transforms:</p><pre><code>ab → x
abc → y
abef → z
bc → m
beq → n
</code></pre><p>Here's what happens when the user types various sequence characters:</p><table>
<thead>
<tr>
<th>Input characters</th>
<th>Result</th>
<th>Comments</th>
</tr>
</thead>
<tbody><tr>
<td>ab</td>
<td></td>
<td>No output, since there is a longer transform with this as prefix.</td>
</tr>
<tr>
<td>abc</td>
<td>y</td>
<td>Complete transform match.</td>
</tr>
<tr>
<td>abd</td>
<td>xd</td>
<td>The longest match is "ab", so that is converted and output. The 'd' follows, since it is not the start of any transform.</td>
</tr>
<tr>
<td>abeq</td>
<td>xeq</td>
<td>"ab" wins over "beq", since it comes first. That is, there is no longer possible match starting with 'a'.</td>
</tr>
<tr>
<td>bc</td>
<td>m</td>
<td></td>
</tr>
</tbody></table><p>Control characters, combining marks and whitespace in this attribute are escaped using the <code>\u{...}</code> notation.</p><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>This attribute represents the characters that are output from the transform. The output can contain more than one character, so you could have <code>&lt;transform from="´A" to="Fred"/&gt;</code></p>
</blockquote><p>Control characters, whitespace (other than the regular space character) and combining marks in this attribute are escaped using the <code>\u{...}</code> notation.</p><p>Examples</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"fr-CA-t-k0-CSA-osx"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"á"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Á"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"é"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´E"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"É"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´i"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"í"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´I"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Í"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´o"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"ó"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´O"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Ó"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´u"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"ú"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"´U"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Ú"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"nl-BE-t-k0-chromeos"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u{30c}a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"ǎ"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- ̌a → ǎ --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u{30c}A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Ǎ"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- ̌A → Ǎ --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u{30a}a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"å"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- ̊a → å --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u{30a}A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Å"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- ̊A → Å --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p><em>Attribute:</em> <code>before</code> (optional)</p><blockquote>
<p>This attribute consists of a sequence of elements (codepoint or UnicodeSet) to match the text up to the current position in the text (this is similar to a regex "look behind" assertion: <code>(?&lt;=a)b</code> matches a "b" that is preceded by an "a"). The attribute must match for the transform to apply. If missing, no before constraint is applied. The attribute value must not be empty.</p>
</blockquote><p><em>Attribute:</em> <code>after</code> (optional)</p><blockquote>
<p>This attribute consists of a sequence of elements (codepoint or UnicodeSet) and matches as a zero-width assertion after the <code>@from</code> sequence. The attribute must match for the transform to apply. If missing, no after constraint is applied. The attribute value must not be empty. When the transform is applied, the string matched by the <code>@from</code> attribute is replaced by the string in the <code>@to</code> attribute, with the text matched by the <code>@after</code> attribute left unchanged. After the change, the current position is reset to just after the text output from the <code>@to</code> attribute and just before the text matched by the <code>@after</code> attribute. Warning: some legacy implementations may not be able to make such an adjustment and will place the current position after the <code>@after</code> matched string.</p>
</blockquote><p><em>Attribute:</em> <code>error="fail"</code> (optional)</p><blockquote>
<p>If set this attribute indicates that the keyboarding application may indicate an error to the user in some way. Processing may stop and rewind to any state before the key was pressed. If processing does stop, no further transforms on the same input are applied. The <code>@error</code> attribute takes the value <code>"fail"</code>, or must be absent. If processing continues, the <code>@to</code> is used for output as normal. It thus should contain a reasonable value.</p>
</blockquote><p>For example:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u037A\u037A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u037A"</span> <span class="hljs-attr">error</span>=<span class="hljs-string">"fail"</span> /&gt;</span>
</code></pre><p>This indicates that it is an error to type two iota subscripts immediately after each other.</p><p>In terms of how these different attributes work in processing a sequences of transforms, consider the transform:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"X"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"Y"</span> <span class="hljs-attr">after</span>=<span class="hljs-string">"Z"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"B"</span> /&gt;</span>
</code></pre><p>This would transform the string:</p><pre><code>XYZ → XBZ
</code></pre><p>If we mark where the current match position is before and after the transform we see:</p><pre><code>X | Y Z → X B | Z
</code></pre><p>And a subsequent transform could transform the Z string, looking back (using @before) to match the B.</p><hr><h3 id="520-element-reorders-reorder">5.20 <a name="Element_reorder" href="#Element_reorder">Element: reorders, reorder</a></h3><p>The reorder transform is applied after all transform except for those with <code>type="final"</code>.</p><p>This transform has the job of reordering sequences of characters that have been typed, from their typed order to the desired output order. The primary concern in this transform is to sort combining marks into their correct relative order after a base, as described in this section. The reorder transforms can be quite complex, keyboard layouts will almost always import them.</p><p>The reordering algorithm consists of four parts:</p><ol>
<li>Create a sort key for each character in the input string. A sort key has 4 parts: (primary, index, tertiary).<ul>
<li>The <strong>primary weight</strong> is the primary order value.</li>
<li>The <strong>secondary weight</strong> is the index, a position in the input string, usually of the character itself, but it may be of a character earlier in the string.</li>
<li>The <strong>tertiary weight</strong> is a tertiary order value (defaulting to 0).</li>
<li>The <strong>quaternary weight</strong> is the index of the character in the string. This is solely to ensure a stable sort for sequences of characters with the same tertiary weight.</li>
</ul>
</li>
<li>Mark each character as to whether it is a prebase character, one that is typed before the base and logically stored after. Thus it will have a primary order &gt; 0.</li>
<li>Use the sort key and the prebase mark to identify runs. A run starts with a prefix that contains any prebase characters and a single base character whose primary and tertiary key is 0. The run extends until, but not including, the start of the prefix of the next run or end of the string.<ul>
<li><code>run := prebase* (primary=0 &amp;&amp; tertiary=0) ((primary≠0 || tertiary≠0) &amp;&amp; !prebase)*</code></li>
</ul>
</li>
<li>Sort the character order of each character in the run based on its sort key.</li>
</ol><p>The primary order of a character with the Unicode property Combining_Character_Class (ccc) of 0 may well not be 0. In addition, a character may receive a different primary order dependent on context. For example, in the Devanagari sequence ka halant ka, the first ka would have a primary order 0 while the halant ka sequence would give both halant and the second ka a primary order &gt; 0, for example 2. Note that “base” character in this discussion is not a Unicode base character. It is instead a character with primary=0.</p><p>In order to get the characters into the correct relative order, it is necessary not only to order combining marks relative to the base character, but also to order some combining marks in a subsequence following another combining mark. For example in Devanagari, a nukta may follow consonant character, but it may also follow a conjunct consisting of consonant, halant, consonant. Notice that the second consonant is not, in this model, the start of a new run because some characters may need to be reordered to before the first base, for example repha. The repha would get primary &lt; 0, and be sorted before the character with order = 0, which is, in the case of Devanagari, the initial consonant of the orthographic syllable.</p><p>The reorder transform consists of a single element type: <code>&lt;reorder&gt;</code> encapsulated in a <code>&lt;reorders&gt;</code> element. Each is a rule that matches against a string of characters with the action of setting the various ordering attributes (<code>primary</code>, <code>tertiary</code>, <code>tertiary_base</code>, <code>prebase</code>) for the matched characters in the string.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{combination of characters}"</span>
   [<span class="hljs-attr">before</span>=<span class="hljs-string">"{look-behind required match}"</span>]
   [<span class="hljs-attr">after</span>=<span class="hljs-string">"{look-ahead required match}"</span>]
   [<span class="hljs-attr">order</span>=<span class="hljs-string">"{list of weights}"</span>]
   [<span class="hljs-attr">tertiary</span>=<span class="hljs-string">"{list of weights}"</span>]
   [<span class="hljs-attr">tertiary_base</span>=<span class="hljs-string">"{list of true/false}"</span>]
   [<span class="hljs-attr">prebase</span>=<span class="hljs-string">"{list of true/false}"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_reorder">reorders</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>from</code> (required)</p><blockquote>
<p>This attribute follows the <code>transform/@from</code> attribute and contains a string of elements. Each element matches one character and may consist of a codepoint or a UnicodeSet (both as defined in UTS#35 section 5.3.3).</p>
</blockquote><p><em>Attribute:</em> <code>before</code></p><blockquote>
<p>This attribute follows the <code>transform/@before</code> attribute and contains the element string that must match the string immediately preceding the start of the string that the @from matches.</p>
</blockquote><p><em>Attribute:</em> <code>after</code></p><blockquote>
<p>This attribute follows the <code>transform/@after</code> attribute and contains the element string that must match the string immediately following the end of the string that the <code>@from</code> matches.</p>
</blockquote><p><em>Attribute:</em> <code>order</code></p><blockquote>
<p>This attribute gives the primary order for the elements in the matched string in the <code>@from</code> attribute. The value is a simple integer between -128 and +127 inclusive, or a space separated list of such integers. For a single integer, it is applied to all the elements in the matched string. Details of such list type attributes are given after all the attributes are described. If missing, the order value of all the matched characters is 0. We consider the order value for a matched character in the string.</p>
<ul>
<li>If the value is 0 and its tertiary value is 0, then the character is the base of a new run.</li>
<li>If the value is 0 and its tertiary value is non-zero, then it is a normal character in a run, with ordering semantics as described in the <code>@tertiary</code> attribute.</li>
<li>If the value is negative, then the character is a primary character and will reorder to be before the base of the run.</li>
<li>If the value is positive, then the character is a primary character and is sorted based on the order value as the primary key following a previous base character.</li>
</ul>
<p>A character with a zero tertiary value is a primary character and receives a sort key consisting of:</p>
<ul>
<li>Primary weight is the order value</li>
<li>Secondary weight is the index of the character. This may be any value (character index, codepoint index) such that its value is greater than the character before it and less than the character after it.</li>
<li>Tertiary weight is 0.</li>
<li>Quaternary weight is the same as the secondary weight.</li>
</ul>
</blockquote><p><em>Attribute:</em> <code>tertiary</code></p><blockquote>
<p>This attribute gives the tertiary order value to the characters matched. The value is a simple integer between -128 and +127 inclusive, or a space separated list of such integers. If missing, the value for all the characters matched is 0. We consider the tertiary value for a matched character in the string.</p>
<ul>
<li>If the value is 0 then the character is considered to have a primary order as specified in its order value and is a primary character.</li>
<li>If the value is non zero, then the order value must be zero otherwise it is an error. The character is considered as a tertiary character for the purposes of ordering.</li>
</ul>
<p>A tertiary character receives its primary order and index from a previous character, which it is intended to sort closely after. The sort key for a tertiary character consists of:</p>
<ul>
<li>Primary weight is the primary weight of the primary character</li>
<li>Secondary weight is the index of the primary character, not the tertiary character</li>
<li>Tertiary weight is the tertiary value for the character.</li>
<li>Quaternary weight is the index of the tertiary character.</li>
</ul>
</blockquote><p><em>Attribute:</em> <code>tertiary_base</code></p><blockquote>
<p>This attribute is a space separated list of <code>"true"</code> or <code>"false"</code> values corresponding to each character matched. It is illegal for a tertiary character to have a true <code>tertiary_base</code> value. For a primary character it marks that this character may have tertiary characters moved after it. When calculating the secondary weight for a tertiary character, the most recently encountered primary character with a true <code>tertiary_base</code> attribute is used. Primary characters with an <code>@order</code> value of 0 automatically are treated as having <code>tertiary_base</code> true regardless of what is specified for them.</p>
</blockquote><p><em>Attribute:</em> <code>prebase</code></p><blockquote>
<p>This attribute gives the prebase attribute for each character matched. The value may be <code>"true"</code> or <code>"false"</code> or a space separated list of such values. If missing the value for all the characters matched is false. It is illegal for a tertiary character to have a true prebase value.</p>
<p>If a primary character has a true prebase value then the character is marked as being typed before the base character of a run, even though it is intended to be stored after it. The primary order gives the intended position in the order after the base character, that the prebase character will end up. Thus <code>@order</code> shall not be 0. These characters are part of the run prefix. If such characters are typed then, in order to give the run a base character after which characters can be sorted, an appropriate base character, such as a dotted circle, is inserted into the output run, until a real base character has been typed. A value of <code>"false"</code> indicates that the character is not a prebase.</p>
</blockquote><p>There is no <code>@error</code> attribute.</p><p>For <code>@from</code> attributes with a match string length greater than 1, the sort key information (<code>@order</code>, <code>@tertiary</code>, <code>@tertiary_base</code>, <code>@prebase</code>) may consist of a space separated list of values, one for each element matched. The last value is repeated to fill out any missing values. Such a list may not contain more values than there are elements in the <code>@from</code> attribute:</p><pre><code>if len(@from) &lt; len(@list) then error
else
    while len(@from) &gt; len(@list)
        append lastitem(@list) to @list
    endwhile
endif
</code></pre><p><strong>Example</strong></p><p>For example, consider the word Northern Thai (nod-Lana) word: ᨡ᩠ᩅᩫ᩶ 'roasted'. This is ideally encoded as the following:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
<th><em>o</em></th>
<th><em>t2</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A60</td>
<td>1A45</td>
<td>1A6B</td>
<td>1A76</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>230</td>
</tr>
</tbody></table><p>(That sequence is already in NFC format.)</p><p>Some users may type the upper component of the vowel first, and the tone before or after the lower component. Thus someone might type it as:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>t2</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A76</td>
<td>1A60</td>
<td>1A45</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>230</td>
<td>9</td>
<td>0</td>
</tr>
</tbody></table><p>The Unicode NFC format of that typed value reorders to:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>sakot</em></th>
<th><em>t2</em></th>
<th><em>wa</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A60</td>
<td>1A76</td>
<td>1A45</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>9</td>
<td>230</td>
<td>0</td>
</tr>
</tbody></table><p>Finally, the user might also type in the sequence with the tone <em>after</em> the lower component.</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
<th><em>t2</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A60</td>
<td>1A45</td>
<td>1A76</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>230</td>
</tr>
</tbody></table><p>(That sequence is already in NFC format.)</p><p>We want all of these sequences to end up ordered as the first. To do this, we use the following rules:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"127"</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- max possible order --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"42"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1A75-\u1A79]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"55"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B[\u1A75-\u1A79]"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60[\u1A75-\u1A79]\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10 55 10"</span> /&gt;</span>
</code></pre><p>The first reorder is the default ordering for the <em>sakot</em> which allows for it to be placed anywhere in a sequence, but moves any non-consonants that may immediately follow it, back before it in the sequence. The next two rules give the orders for the top vowel component and tone marks respectively. The next three rules give the <em>sakot</em> and <em>wa</em> characters a primary order that places them before the <em>o</em>. Notice particularly the final reorder rule where the <em>sakot</em>+<em>wa</em> is split by the tone mark. This rule is necessary in case someone types into the middle of previously normalized text.</p><p><code>&lt;reorder&gt;</code> elements are priority ordered based first on the length of string their <code>@from</code> attribute matches and then the sum of the lengths of the strings their <code>@before</code> and <code>@after</code> attributes match.</p><p>If a layout has two <code>&lt;reorders&gt;</code> elements, e.g. from importing one and specifying the second, then <code>&lt;reorder&gt;</code> elements are merged. The @from string in a <code>&lt;reorder&gt;</code> element describes a set of strings that it matches. This also holds for the <code>@before</code> and <code>@after</code> attributes. The intersection of two <code>&lt;reorder&gt;</code> elements consists of the intersections of their <code>@from</code>, <code>@before</code> and <code>@after</code> string sets. It is illegal for the intersection between any two <code>&lt;reorder&gt;</code> elements in the same <code>&lt;reorders&gt;</code> element to be non empty, although implementors are encouraged to have pity on layout authors when reporting such errors, since they can be hard to track down.</p><p>If two <code>&lt;reorder&gt;</code> elements in two different <code>&lt;reorders&gt;</code> elements have a non empty intersection, then they are split and merged. They are split such that where there were two <code>&lt;reorder&gt;</code> elements, there are, in effect (but not actuality), three elements consisting of:</p><ul>
<li><code>@from</code>, <code>@before</code>, <code>@after</code> that match the intersection of the two rules. The other attributes are merged, as described below.</li>
<li><code>@from</code>, <code>@before</code>, <code>@after</code> that match the set of strings in the first rule not in the intersection with the other attributes from the first rule.</li>
<li><code>@from</code>, <code>@before</code>, <code>@after</code> that match the set of strings in the second rule not in the intersection, with the other attributes from the second rule.</li>
</ul><p>When merging the other attributes, the second rule is taken to have priority (occurring later in the layout description file). Where the second rule does not define the value for a character but the first does, it is taken from the first rule, otherwise it is taken from the second rule.</p><p>Notice that it is possible for two rules to match the same string, but for them not to merge because the distribution of the string across <code>@before</code>, <code>@from</code>, and <code>@after</code> is different. For example:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"ab"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"cd"</span> <span class="hljs-attr">after</span>=<span class="hljs-string">"e"</span> /&gt;</span>
</code></pre><p>would not merge with:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"bcd"</span> <span class="hljs-attr">after</span>=<span class="hljs-string">"e"</span> /&gt;</span>
</code></pre><p>When two <code>&lt;reorders&gt;</code> elements merge as the result of an import, the resulting <code>reorder</code> elements are sorted into priority order for matching.</p><p>Consider this fragment from a shared reordering for the Myanmar script:</p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- medial-r --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u103C"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"20"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- [medial-wa or shan-medial-wa] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103D\u1082]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"25"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- [medial-ha or shan-medial-wa]+asat = Mon asat --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103E\u1082]\u103A"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"27"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- [medial-ha or mon-medial-wa] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103E\u1060]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"27"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- [e-vowel or shan-e-vowel] --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1031\u1084]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"30"</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u102D\u102E\u1033-\u1035\u1071-\u1074\u1085\u109D\uA9E5]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"35"</span> /&gt;</span>
</code></pre><p>A particular Myanmar keyboard layout can have this <code>reorders</code> element:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorders</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Kinzi --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1004\u103A\u1039"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"-1"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1031"</span> <span class="hljs-attr">prebase</span>=<span class="hljs-string">"1"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- medial-r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u103C"</span> <span class="hljs-attr">prebase</span>=<span class="hljs-string">"1"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">reorders</span>&gt;</span>
</code></pre><p>The effect of this that the <em>e-vowel</em> will be identified as a prebase and will have an order of 30. Likewise a <em>medial-r</em> will be identified as a prebase and will have an order of 20. Notice that a <em>shan-e-vowel</em> will not be identified as a prebase (even if it should be!). The <em>kinzi</em> is described in the layout since it moves something across a run boundary. By separating such movements (prebase or moving to in front of a base) from the shared ordering rules, the shared ordering rules become a self-contained combining order description that can be used in other keyboards or even in other contexts than keyboarding.</p><hr><h3 id="521-element-transform-final">5.21 <a name="Element_final" href="#Element_final">Element: transform final</a></h3><p>The final transform is applied after the reorder transform. It executes in a similar way to the simple transform with the settings ignored, as if there were no settings in the <code>&lt;settings&gt;</code> element.</p><p><strong>Example</strong></p><p>This is an example from Khmer where split vowels are combined after reordering.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"final"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u17C1\u17B8"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u17BE"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u17C1\u17B6"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u17C4"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p>Another example allows a keyboard implementation to alert or stop people typing two lower vowels in a Burmese cluster:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u102F\u1030\u1048\u1059][\u102F\u1030\u1048\u1059]"</span> <span class="hljs-attr">error</span>=<span class="hljs-string">"fail"</span> /&gt;</span>
</code></pre><hr><h3 id="522-element-backspaces">5.22 <a name="Element_backspaces" href="#Element_backspaces">Element: backspaces</a></h3><p>The backspace transform is an optional transform that is not applied on input of normal characters, but is only used to perform extra backspace modifications to previously committed text.</p><p>Keyboarding applications typically, but are not required, to work in one of two modes:</p><p><strong><em>text entry</em></strong></p><blockquote>
<p>text entry happens while a user is typing new text. A user typically wants the backspace key to undo whatever they last typed, whether or not they typed things in the 'right' order.</p>
</blockquote><p><strong><em>text editing</em></strong></p><blockquote>
<p>text editing happens when a user moves the cursor into some previously entered text which may have been entered by someone else. As such, there is no way to know in which order things were typed, but a user will still want appropriate behaviour when they press backspace. This may involve deleting more than one character or replacing a sequence of characters with a different sequence.</p>
</blockquote><p>In the text entry mode, there is no need for any special description of backspace behaviour. A keyboarding application will typically keep a history of previous output states and just revert to the previous state when backspace is hit.</p><p>In text editing mode, different keyboard layouts may behave differently in the same textual context. The backspace transform allows the keyboard layout to specify the effect of pressing backspace in a particular textual context. This is done by specifying a set of backspace rules that match a string before the cursor and replace it with another string. The rules are expressed as <code>backspace</code> elements encapsulated in a <code>backspaces</code> element.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspaces</span>&gt;</span>
    {a set of backspace elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">backspace</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_backspace">backspace</a>
Occurence: optional, single</p>
</small>
</blockquote><hr><h3 id="523-element-backspace">5.23 <a name="Element_backspace" href="#Element_backspace">Element: backspace</a></h3><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{combination of characters}"</span> [<span class="hljs-attr">to</span>=<span class="hljs-string">"{output}"</span>]
   [<span class="hljs-attr">before</span>=<span class="hljs-string">"{look-behind required match}"</span>]
   [<span class="hljs-attr">after</span>=<span class="hljs-string">"{look-ahead required match}"</span>]
   [<span class="hljs-attr">error</span>=<span class="hljs-string">"fail"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_backspaces">backspaces</a>
Children: <em>none</em>
Occurence: required, multiple</p>
</small>
</blockquote><p>The <code>backspace</code> element has the same <code>@before</code>, <code>@from</code>, <code>@after</code>, <code>@to</code>, <code>@error</code> of the <code>transform</code> element. The <code>@to</code> is optional with <code>backspace</code>.</p><p><strong>Example</strong></p><p>For example, consider deleting a Devanagari ksha:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspaces</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u0915\u094D\u0936"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">backspaces</span>&gt;</span>
</code></pre><p>Here there is no <code>@to</code> attribute since the whole string is being deleted. This is not uncommon in the backspace transforms.</p><p>A more complex example comes from a Burmese visually ordered keyboard:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspaces</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Kinzi --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1004\u101B\u105A]\u103A\u1039"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- subjoined consonant --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021\u1050\u1051\u105A-\u105D]"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- tone mark --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u102B\u103A"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- Handle prebases --&gt;</span>
    <span class="hljs-comment">&lt;!-- diacritics stored before e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103A-\u103F\u105E-\u1060\u1082]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u1031"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- diacritics stored before medial r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103A-\u103B\u105E-\u105F]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u103C"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- subjoined consonant before e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u1031"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- base consonant before e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1000-\u102A\u103F-\u1049\u104E]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\uFDDF\u1031"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- subjoined consonant before medial r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u103C"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- base consonant before medial r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1000-\u102A\u103F-\u1049\u104E]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\uFDDF\u103C"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- delete lone medial r or e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\uFDDF[\u1031\u103C]"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">backspaces</span>&gt;</span>
</code></pre><p>The above example is simplified, and doesn't fully handle the interaction between medial-r and e-vowel.</p><p>The character \uFDDF does not represent a literal character, but is instead a special placeholder, a "filler string". When a keyboard implementation handles a user pressing a key that inserts a prebase character, it also has to insert a special filler string before the prebase to ensure that the prebase character does not combine with the previous cluster. See the reorder transform for details. The precise filler string is implementation dependent. Rather than requiring keyboard layout designers to know what the filler string is, we reserve a special character that the keyboard layout designer may use to reference this filler string. It is up to the keyboard implementation to, in effect, replace that character with the filler string.</p><p>The first three transforms above delete various ligatures with a single keypress. The other transforms handle prebase characters. There are two in this Burmese keyboard. The transforms delete the characters preceding the prebase character up to base which gets replaced with the prebase filler string, which represents a null base. Finally the prebase filler string + prebase is deleted as a unit.</p><p>The backspace transform is much like other transforms except in its processing model. If we consider the same transform as in the simple transform example, but as a backspace:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspace</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"X"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"Y"</span> <span class="hljs-attr">after</span>=<span class="hljs-string">"Z"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"B"</span>/&gt;</span>
</code></pre><p>This would transform the string:</p><pre><code>XYZ → XBZ
</code></pre><p>If we mark where the current match position is before and after the transform we see:</p><pre><code>X Y | Z → X B | Z
</code></pre><p>Whereas a simple or final transform would then run other transforms in the transform list, advancing the processing position until it gets to the end of the string, the backspace transform only matches a single backspace rule and then finishes.</p><hr><h2 id="6-element-hierarchy---platform-file">6 <a name="Element_Heirarchy_Platform_File" href="#Element_Heirarchy_Platform_File">Element Hierarchy - Platform File</a></h2><p>There is a separate XML structure for platform-specific configuration elements. The most notable component is a mapping between the hardware key codes to the ISO layout positions for that platform.</p><h3 id="61-element-platform">6.1 <a name="Element_platform" href="#Element_platform">Element: platform</a></h3><p>This is the top level element. This element contains a set of elements defined below. A document shall only contain a single instance of this element.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">platform</span>&gt;</span>
    {platform-specific elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">platform</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <em>none</em>
Children: <a href="#Element_hardwareMap">hardwareMap</a>
Occurence: required, single</p>
</small>
</blockquote><h3 id="62-element-hardwaremap">6.2 <a name="Element_hardwareMap" href="#Element_hardwareMap">Element: hardwareMap</a></h3><p>This element must have a <code>platform</code> element as its parent. This element contains a set of map elements defined below. A document shall only contain a single instance of this element.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">platform</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hardwareMap</span>&gt;</span>
        {a set of map elements}
    <span class="hljs-tag">&lt;/<span class="hljs-name">hardwareMap</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">platform</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_platform">platform</a>
Children: <a href="#Element_hardwareMap_map">map</a>
Occurence: optional, single</p>
</small>
</blockquote><h3 id="63-element-map">6.3 <a name="Element_hardwareMap_map" href="#Element_hardwareMap_map">Element: map</a></h3><p>This element must have a <code>hardwareMap</code> element as its parent. This element maps between a hardware keycode and the corresponding ISO layout position of the key.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"{hardware keycode}"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"{ISO layout position}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

</small><p><small>Parents: <a href="#Element_hardwareMap">hardwareMap</a>
Children: <em>none</em>
Occurence: required, multiple
</small></p>
</blockquote><p><em>Attribute:</em> <code>keycode</code> (required)</p><blockquote>
<p>The hardware key code value of the key. This value is an integer which is provided by the keyboard driver.</p>
</blockquote><p><em>Attribute:</em> <code>iso</code> (required)</p><blockquote>
<p>The corresponding position of a key using the ISO layout convention where rows are identified by letters and columns are identified by numbers. For example, "D01" corresponds to the "Q" key on a US keyboard. (See the definition at the beginning of the document for a diagram).</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">platform</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">hardwareMap</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E01"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"3"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E02"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"4"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E03"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E04"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"6"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E05"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"7"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E06"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">keycode</span>=<span class="hljs-string">"41"</span> <span class="hljs-attr">iso</span>=<span class="hljs-string">"E00"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">hardwareMap</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">platform</span>&gt;</span>
</code></pre><hr><h2 id="7-invariants">7 <a name="Invariants" href="#Invariants">Invariants</a></h2><p>Beyond what the DTD imposes, certain other restrictions on the data are imposed on the data.</p><ol>
<li> For a given platform, every <code>map[@iso]</code> value must be in the hardwareMap if there is one (<code>_keycodes.xml</code>)</li>
<li> Every <code>map[@base]</code> value must also be in <code>base[@base]</code> value</li>
<li>No <code>keyMap[@modifiers]</code> value can overlap with another <code>keyMap[@modifiers]</code> value.<ul>
<li>eg you can't have <code>"RAlt Ctrl"</code> in one <code>keyMap</code>, and <code>"Alt Shift"</code> in another (because Alt = RAltLAlt).</li>
</ul>
</li>
<li>Every sequence of characters in a <code>transform[@from]</code> value must be a concatenation of two or more <code>map[@to]</code> values.<ul>
<li>eg with <code>&lt;transform from="xyz" to="q"&gt;</code> there must be some map values to get there, such as <code>&lt;map... to="xy"&gt;</code> &amp; <code>&lt;map... to="z"&gt;</code></li>
</ul>
</li>
<li> If the base and chars values for <code>modifiers=""</code> are all identical, and there are no longpresses, that <code>keyMap</code> must not appear (??)</li>
<li> There will never be overlaps among modifier values.</li>
<li>A modifier set will never have ? (optional) on all values<ul>
<li>eg, you'll never have <code>RCtrl?Caps?LShift?</code></li>
</ul>
</li>
<li> Every <code>base[@base</code>] value must be unique.</li>
<li>A <code>modifier</code> attribute value will aways be minimal, observing the following simplification rules.</li>
</ol><table>
<thead>
<tr>
<th>Notation</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Lower case character (eg. <em>x</em> )</td>
<td>Interpreted as any combination of modifiers. <br> (eg. <em>x</em> = CtrlShiftOption)</td>
</tr>
<tr>
<td>Upper-case character (eg. <em>Y</em> )</td>
<td>Interpreted as a single modifier key (which may or may not have a L and R variant) <br> (eg. <em>Y</em> = Ctrl, <em>RY</em> = RCtrl, etc..)</td>
</tr>
<tr>
<td>Y? ⇔ Y ∨ ∅ <br> Y ⇔ LY ∨ RY ∨ LYRY</td>
<td>Eg. Opt? ⇔ ROpt ∨ LOpt ∨ ROptLOpt ∨ ∅ <br> Eg. Opt ⇔ ROpt ∨ LOpt ∨ ROptLOpt</td>
</tr>
</tbody></table><table>
<thead>
<tr>
<th>Axiom</th>
<th>Example</th>
</tr>
</thead>
<tbody><tr>
<td>xY ∨ x ⇒ xY?</td>
<td>OptCtrlShift OptCtrl → OptCtrlShift?</td>
</tr>
<tr>
<td>xRY ∨ xY? ⇒ xY? <br> xLY ∨ xY? ⇒ xY?</td>
<td>OptCtrlRShift OptCtrlShift? → OptCtrlShift?</td>
</tr>
<tr>
<td>xRY? ∨ xY ⇒ xY? <br> xLY? ∨ xY ⇒ xY?</td>
<td>OptCtrlRShift? OptCtrlShift → OptCtrlShift?</td>
</tr>
<tr>
<td>xRY? ∨ xY? ⇒ xY? <br> xLY? ∨ xY? ⇒ xY?</td>
<td>OptCtrlRShift? OptCtrlShift? → OptCtrlShift?</td>
</tr>
<tr>
<td>xRY ∨ xY ⇒ xY <br> xLY ∨ xY ⇒ xY</td>
<td>OptCtrlRShift OptCtrlShift → OptCtrlShift?</td>
</tr>
<tr>
<td>LY?RY?</td>
<td>OptRCtrl?LCtrl? → OptCtrl?</td>
</tr>
<tr>
<td>xLY? ⋁ xLY ⇒ xLY?</td>
<td></td>
</tr>
<tr>
<td>xY? ⋁ xY ⇒ xY?</td>
<td></td>
</tr>
<tr>
<td>xY? ⋁ x ⇒ xY?</td>
<td></td>
</tr>
<tr>
<td>xLY? ⋁ x ⇒ xLY?</td>
<td></td>
</tr>
<tr>
<td>xLY ⋁ x ⇒ xLY?</td>
<td></td>
</tr>
</tbody></table><hr><h2 id="8-data-sources">8 <a name="Data_Sources" href="#Data_Sources">Data Sources</a></h2><p>Here is a list of the data sources used to generate the initial key map layouts:</p><h5 id="key-map-data-sources"><a name="Key_Map_Data_Sources" href="#Key_Map_Data_Sources">Key Map Data Sources</a></h5><table>
<thead>
<tr>
<th>Platform</th>
<th>Source</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>Android</td>
<td>Android 4.0 - Ice Cream Sandwich (<a href="https://source.android.com/source/downloading.html">https://source.android.com/source/downloading.html</a>)</td>
<td>Parsed layout files located in packages/inputmethods/LatinIME/java/res</td>
</tr>
<tr>
<td>ChromeOS</td>
<td>XKB (<a href="https://www.x.org/wiki/XKB">https://www.x.org/wiki/XKB</a>)</td>
<td>The ChromeOS represents a very small subset of the keyboards available from XKB.</td>
</tr>
<tr>
<td>Mac OSX</td>
<td>Ukelele bundled System Keyboards (<a href="https://software.sil.org/ukelele/">https://software.sil.org/ukelele/</a>)</td>
<td>These layouts date from Mac OSX 10.4 and are therefore a bit outdated</td>
</tr>
<tr>
<td>Windows</td>
<td>Generated .klc files from the Microsoft Keyboard Layout Creator (<a href="https://support.microsoft.com/en-us/help/823010/the-microsoft-keyboard-layout-creator">https://support.microsoft.com/en-us/help/823010/the-microsoft-keyboard-layout-creator</a>)</td>
<td></td>
</tr>
</tbody></table><hr><h2 id="9-keyboard-ids">9 <a name="Keyboard_IDs" href="#Keyboard_IDs">Keyboard IDs</a></h2><p>There is a set of subtags that help identify the keyboards. Each of these are used after the <code>"t-k0"</code> subtags to help identify the keyboards. The first tag appended is a mandatory platform tag followed by zero or more tags that help differentiate the keyboard from others with the same locale code.</p><h3 id="91-principles-for-keyboard-ids">9.1 <a name="Principles_for_Keyboard_Ids" href="#Principles_for_Keyboard_Ids">Principles for Keyboard Ids</a></h3><p>The following are the design principles for the ids.</p><ol>
<li>BCP47 compliant.<ol>
<li>Eg, <code>en-t-k0-extended</code>.</li>
</ol>
</li>
<li>Use the minimal language id based on <code>likelySubtag</code>s.<ol>
<li>Eg, instead of <code>en-US-t-k0-xxx</code>, use <code>en-t-k0-xxx</code>. Because there is <code>&lt;likelySubtag from="en" to="en_Latn_US"/&gt;</code>, en-US → en.</li>
<li>The data is in <a href="https://github.com/unicode-org/cldr/releases/tag/latest/common/supplemental/likelySubtags.xml">https://github.com/unicode-org/cldr/releases/tag/latest/common/supplemental/likelySubtags.xml</a></li>
</ol>
</li>
<li>The platform goes first, if it exists. If a keyboard on the platform changes over time, both are dated, eg <code>bg-t-k0-chromeos-2011</code>. When selecting, if there is no date, it means the latest one.</li>
<li>Keyboards are only tagged that differ from the "standard for each platform". That is, for each language on a platform, there will be a keyboard with no subtags other than the platform. Subtags with a common semantics across platforms are used, such as <code>-extended</code>, <code>-phonetic</code>, <code>-qwerty</code>, <code>-qwertz</code>, <code>-azerty</code>, …</li>
<li>In order to get to 8 letters, abbreviations are reused that are already in <a href="https://github.com/unicode-org/cldr/releases/tag/latest/common/bcp47/">bcp47</a> -u/-t extensions and in <a href="https://www.iana.org/assignments/language-subtag-registry">language-subtag-registry</a> variants, eg for Traditional use <code>-trad</code> or <code>-traditio</code> (both exist in <a href="https://github.com/unicode-org/cldr/releases/tag/latest/common/bcp47/">bcp47</a>).</li>
<li>Multiple languages cannot be indicated, so the predominant target is used.<ol>
<li>For Finnish + Sami, use <code>fi-t-k0-smi</code> or <code>extended-smi</code></li>
</ol>
</li>
<li>In some cases, there are multiple subtags, like <code>en-US-t-k0-chromeos-intl-altgr.xml</code></li>
<li>Otherwise, platform names are used as a guide.</li>
</ol><hr><h2 id="10-platform-behaviors-in-edge-cases">10 <a name="Platform_Behaviors_in_Edge_Cases" href="#Platform_Behaviors_in_Edge_Cases">Platform Behaviors in Edge Cases</a></h2><table>
<thead>
<tr>
<th>Platform</th>
<th>No modifier combination match is available</th>
<th>No map match is available for key position</th>
<th>Transform fails (ie. if ^d is pressed when that transform does not exist)</th>
</tr>
</thead>
<tbody><tr>
<td>ChromeOS</td>
<td>Fall back to base</td>
<td>Fall back to character in a keyMap with same "level" of modifier combination. If this character does not exist, fall back to (n-1) level. (This is handled data-generation side). <br> In the spec: No output</td>
<td>No output at all</td>
</tr>
<tr>
<td>Mac OSX</td>
<td>Fall back to base (unless combination is some sort of keyboard shortcut, eg. cmd-c)</td>
<td>No output</td>
<td>Both keys are output separately</td>
</tr>
<tr>
<td>Windows</td>
<td>No output</td>
<td>No output</td>
<td>Both keys are output separately</td>
</tr>
</tbody></table><hr><p>Copyright © 2001–2022 Unicode, Inc. All Rights Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability for errors or omissions. No liability is assumed for incidental and consequential damages in connection with or arising out of the use of the information or programs contained or accompanying this technical report. The Unicode <a href="https://unicode.org/copyright.html">Terms of Use</a> apply.</p><p>Unicode and the Unicode logo are trademarks of Unicode, Inc., and are registered in some jurisdictions.</p></div><script>anchors.add()</script></body></html>