<!DOCTYPE html>
<html><head><meta charset="utf-8">
<link rel="stylesheet" type="text/css" media="screen" href="../reports-v2.css">
<title>Unicode Locale Data Markup Language (LDML) Part 7: Keyboards</title></head><body>












































































































































































































































































































































































































































































































































































































































































































































<script src="./js/anchor.min.js"></script><div class="header"><table class="header" cellpadding="0" cellspacing="0" width="100%">
    <tbody>
        <tr>
            <td class="icon"><a href="https://www.unicode.org/"><img style="vertical-align:middle;border:0" alt="[Unicode]" src="https://www.unicode.org/webscripts/logo60s2.gif" height="33" width="34"></a>&nbsp;&nbsp;<a class="bar" href="https://www.unicode.org/reports/">Technical Reports</a>
            </td>
        </tr>
        <tr>
            <td class="gray">&nbsp;</td>
        </tr>
    </tbody>
</table></div><div class="body"><h2 id="unicode-technical-standard-35-tech-preview">Unicode Technical Standard #35 Tech Preview</h2><h1 id="unicode-locale-data-markup-language-ldmlpart-7-keyboards">Unicode Locale Data Markup Language (LDML)<br>Part 7: Keyboards</h1><table class="simple" width="90%">
<thead>
<tr>
<th>Version</th>
<th>44 (draft)</th>
</tr>
</thead>
<tbody><tr>
<td>Editors</td>
<td>Steven Loomis (<a href="mailto:srloomis@unicode.org">srloomis@unicode.org</a>) and <a href="tr35.html#Acknowledgments">other CLDR committee members</a></td>
</tr>
</tbody></table><p>For the full header, summary, and status, see <a href="tr35.html">Part 1: Core</a>.</p><h4 id="important-note"><em>Important Note</em></h4><blockquote>
<p>This is a technical preview of a future version of the LDML Part 7. See <a href="#status"><em>Status</em></a>, below.</p>
<p>There are breaking changes, see <a href="#Compatibility_Notice">Compatibility Notice</a></p>
</blockquote><h3 id="summary"><em>Summary</em></h3><p>This document describes parts of an XML format (<em>vocabulary</em>) for the exchange of structured locale data. This format is used in the <a href="https://www.unicode.org/cldr/">Unicode Common Locale Data Repository</a>.</p><p>This is a partial document, describing keyboard mappings. For the other parts of the LDML see the <a href="tr35.html">main LDML document</a> and the links above.</p><p><em>Note:</em>
Some links may lead to in-development or older
versions of the data files.
See <a href="https://cldr.unicode.org">https://cldr.unicode.org</a> for up-to-date CLDR release data.</p><h3 id="status"><em>Status</em></h3><p>This document is a draft of a <em>technical preview</em> of the Keyboard standard.
This document has <em>not</em> been approved for publication by the Unicode Consortium,
and may be substantially altered before any publication. For the latest published version of UTS#35, see <a href="https://www.unicode.org/reports/tr35/">https://www.unicode.org/reports/tr35/</a></p><p>In particular, Element and attribute names are expected to change pending further review.</p><p>The CLDR <a href="https://cldr.unicode.org/index/keyboard-workgroup">Keyboard Workgroup</a> is currently
developing major changes to the CLDR keyboard specification.
For this draft, please see <a href="https://unicode-org.atlassian.net/browse/CLDR-15034">CLDR-15034</a> for
status, the latest information, or to provide feedback.</p><h2 id="Parts"><a name="parts" href="#Parts">Parts</a></h2><p>The LDML specification is divided into the following parts:</p><ul>
<li>Part 1: <a href="tr35.html#Contents">Core</a> (languages, locales, basic structure)</li>
<li>Part 2: <a href="tr35-general.html#Contents">General</a> (display names &amp; transforms, etc.)</li>
<li>Part 3: <a href="tr35-numbers.html#Contents">Numbers</a> (number &amp; currency formatting)</li>
<li>Part 4: <a href="tr35-dates.html#Contents">Dates</a> (date, time, time zone formatting)</li>
<li>Part 5: <a href="tr35-collation.html#Contents">Collation</a> (sorting, searching, grouping)</li>
<li>Part 6: <a href="tr35-info.html#Contents">Supplemental</a> (supplemental data)</li>
<li>Part 7: <a href="tr35-keyboards.html#Contents">Keyboards</a> (keyboard mappings)</li>
<li>Part 8: <a href="tr35-personNames.html#Contents">Person Names</a> (person names)</li>
</ul><h2 id="Contents"><a name="contents-of-part-7-keyboards" href="#Contents">Contents of Part 7, Keyboards</a></h2><ul>
<li><a href="#important-note"><em>Important Note</em></a></li>
<li><a href="#summary"><em>Summary</em></a></li>
<li><a href="#status"><em>Status</em></a></li>
<li><a href="#Parts">Parts</a></li>
<li><a href="#Contents">Contents of Part 7, Keyboards</a></li>
<li><a href="#Introduction">Keyboards</a></li>
<li><a href="#Goals_and_Nongoals">Goals and Non-goals</a><ul>
<li><a href="#Compatibility_Notice">Compatibility Notice</a></li>
<li><a href="#Accessibility">Accessibility</a></li>
</ul>
</li>
<li><a href="#Definitions">Definitions</a><ul>
<li><a href="#Escaping">Escaping</a></li>
<li><a href="#unicodeset-escaping">UnicodeSet Escaping</a></li>
<li><a href="#uts18-escaping">UTS18 Escaping</a></li>
</ul>
</li>
<li><a href="#File_and_Dir_Structure">File and Directory Structure</a><ul>
<li><a href="#Extensibility">Extensibility</a></li>
</ul>
</li>
<li><a href="#element-hierarchy">Element Hierarchy</a><ul>
<li><a href="#Element_Keyboard">Element: keyboard</a></li>
<li><a href="#Element_locales">Element: locales</a></li>
<li><a href="#Element_locale">Element: locale</a></li>
<li><a href="#Element_version">Element: version</a></li>
<li><a href="#Element_info">Element: info</a></li>
<li><a href="#Element_names">Element: names</a></li>
<li><a href="#Element_name">Element: name</a></li>
<li><a href="#Element_settings">Element: settings</a></li>
<li><a href="#Element_keys">Element: keys</a></li>
<li><a href="#Element_key">Element: key</a><ul>
<li><a href="#implied-keys">Implied Keys</a></li>
<li><a href="#Element_flicks">Elements: flicks, flick</a></li>
</ul>
</li>
<li><a href="#Element_import">Element: import</a></li>
<li><a href="#Element_displays">Element: displays</a></li>
<li><a href="#Element_display">Element: display</a></li>
<li><a href="#Element_displayOptions">Element: displayOptions</a></li>
<li><a href="#Element_forms">Element: forms</a></li>
<li><a href="#Element_form">Element: form</a><ul>
<li><a href="#implied-form-values">Implied Form Values</a></li>
</ul>
</li>
<li><a href="#Element_scanCodes">Element: scanCodes</a></li>
<li><a href="#Element_layers">Element: layers</a></li>
<li><a href="#Element_layer">Element: layer</a></li>
<li><a href="#Element_row">Element: row</a></li>
<li><a href="#Element_vkeys">Element: vkeys</a></li>
<li><a href="#Element_vkey">Element: vkey</a></li>
<li><a href="#Element_variables">Element: variables</a></li>
<li><a href="#element-string">Element: string</a></li>
<li><a href="#element-set">Element: set</a></li>
<li><a href="#element-unicodeset">Element: unicodeSet</a></li>
<li><a href="#Element_transforms">Element: transforms</a><ul>
<li><a href="#markers">Markers</a></li>
</ul>
</li>
<li><a href="#Element_transformGroup">Element: transformGroup</a><ul>
<li><a href="#example-transformgroup-with-transform-elements">Example: <code>transformGroup</code> with <code>transform</code> elements</a></li>
<li><a href="#example-transformgroup-with-reorder-elements">Example: <code>transformGroup</code> with <code>reorder</code> elements</a></li>
</ul>
</li>
<li><a href="#Element_transform">Element: transform</a><ul>
<li><a href="#regex-like-syntax">Regex-like Syntax</a></li>
<li><a href="#additional-features">Additional Features</a></li>
<li><a href="#disallowed-regex-features">Disallowed Regex Features</a></li>
<li><a href="#replacement-syntax">Replacement syntax</a></li>
</ul>
</li>
<li><a href="#Element_reorder">Element: reorder</a><ul>
<li><a href="#using-import-with-reorder-elements">Using <code>&lt;import&gt;</code> with <code>&lt;reorder&gt;</code> elements</a></li>
<li><a href="#example-post-reorder-transforms">Example Post-reorder transforms</a></li>
</ul>
</li>
<li><a href="#Element_backspaces">transform type="backspace"</a></li>
</ul>
</li>
<li><a href="#Invariants">Invariants</a></li>
<li><a href="#Keyboard_IDs">Keyboard IDs</a><ul>
<li><a href="#Principles_for_Keyboard_IDs">Principles for Keyboard IDs</a></li>
</ul>
</li>
<li><a href="#Platform_Behaviors_in_Edge_Cases">Platform Behaviors in Edge Cases</a></li>
<li><a href="#CLDR_VKey_Enum">CLDR VKey Enum</a></li>
<li><a href="#keyboard-test-data">Keyboard Test Data</a><ul>
<li><a href="#test-doctype">Test Doctype</a></li>
<li><a href="#test-element-keyboardtest">Test Element: keyboardTest</a></li>
<li><a href="#test-element-info">Test Element: info</a></li>
<li><a href="#test-element-repertoire">Test Element: repertoire</a></li>
<li><a href="#test-element-tests">Test Element: tests</a></li>
<li><a href="#test-element-test">Test Element: test</a></li>
<li><a href="#test-element-startcontext">Test Element: startContext</a></li>
<li><a href="#test-element-keystroke">Test Element: keystroke</a></li>
<li><a href="#test-element-emit">Test Element: emit</a></li>
<li><a href="#test-element-backspace">Test Element: backspace</a></li>
<li><a href="#test-element-check">Test Element: check</a></li>
<li><a href="#test-examples">Test Examples</a></li>
</ul>
</li>
</ul><h2 id="Introduction"><a name="keyboards" href="#Introduction">Keyboards</a></h2><p>The Unicode Standard and related technologies such as CLDR have dramatically improved the path to language support. However, keyboard support remains platform and vendor specific, causing inconsistencies in implementation as well as timeline.</p><blockquote>
<p>‚ÄúMore and more language communities are determining that digitization is vital to their approach to language preservation and that engagement with Unicode is essential to becoming fully digitized. For many of these communities, however, getting new characters or a new script added to The Unicode Standard is not the end of their journey. The next, often more challenging stage is to get device makers, operating systems, apps and services to implement the script requirements that Unicode has just added to support their language. ‚Ä¶</p>
<p>‚ÄúHowever, commensurate improvements to streamline new language support on the input side have been lacking. CLDR‚Äôs new Keyboard Subcommittee has been established to address this very gap.‚Äù
<em>(Cornelius et. al, ‚ÄúStandardizing Keyboards with CLDR,‚Äù presented at the 45th Internationalization and Unicode Conference, Santa Clara, California, USA, October 2021)</em></p>
</blockquote><p>The CLDR keyboard format seeks to address these challenges, by providing an interchange format for the communication of keyboard mapping data independent of vendors and platforms. Keyboard authors can then create a single mapping file for their language, which implementations can use to provide that language‚Äôs keyboard mapping on their own platform.</p><p>Additionally, the standardized identifier for keyboards can be used to communicate, internally or externally, a request for a particular keyboard mapping that is to be used to transform either text or keystrokes. The corresponding data can then be used to perform the requested actions.  For example, a remote screen-access application (such as used for customer service or server management) would be able to communicate and choose the same keyboard layout on the remote device as is used in front of the user, even if the two systems used different platforms.</p><p>The data can also be used in analysis of the capabilities of different keyboards. It also allows better interoperability by making it easier for keyboard designers to see which characters are generally supported on keyboards for given languages.</p><!-- To illustrate this specification, here is an abridged layout representing the English US 101 keyboard on the macOS operating system (with an inserted long-press example). --><p>For complete examples, see the XML files in the CLDR source repository.</p><hr><h2 id="Goals_and_Nongoals"><a name="goals-and-non-goals" href="#Goals_and_Nongoals">Goals and Non-goals</a></h2><p>Some goals of this format are:</p><ol>
<li>Physical and virtual keyboard layouts defined in a single file.</li>
<li>Provide definitive platform-independent definitions for new keyboard layouts.<ul>
<li>For example, a new French standard keyboard layout would have a single definition which would be usable across all implementations.</li>
</ul>
</li>
<li>Allow platforms to be able to use CLDR keyboard data for the character-emitting keys (non-frame) aspects of keyboard layouts.<ul>
<li>For example, platform-specific keys such as Fn, Numpad, IME swap keys, and cursor keys are out of scope.</li>
<li>This also means that modifier (frame) keys cannot generate output, such as capslock -&gt; backslash.</li>
</ul>
</li>
<li>Deprecate &amp; archive existing LDML platform-specific layouts so they are not part of future releases.</li>
</ol><!--
1. Make the XML as readable as possible.
2. Represent faithfully keyboard data from major platforms: it should be possible to create a functionally-equivalent data file (such that given any input, it can produce the same output).
3. Make as much commonality in the data across platforms as possible to make comparison easy. --><p>Some non-goals (outside the scope of the format) currently are:</p><ol>
<li>Adaptation for screen scaling resolution. Instead, keyboards should define layouts based on physical size. Platforms may interpret physical size definitions and adapt for different physical screen sizes with different resolutions.</li>
<li>Unification of platform-specific vkey and scan code mapping tables.</li>
<li>Unification of pre-existing platform layouts themselves (e.g. existing fr-azerty on platform a, b, c).</li>
<li>Support for prior (pre 3.0) CLDR keyboard files. See <a href="#Compatibility_Notice">Compatibility Notice</a>.</li>
<li>Run-time efficiency. <a href="./tr35.html#Introduction">LDML is explicitly an interchange format</a>, and so it is expected that data will be transformed to a more compact format for use by a keystroke processing engine.</li>
</ol><!-- 1. Display names or symbols for keycaps (eg, the German name for "Return"). If that were added to LDML, it would be in a different structure, outside the scope of this section.
2. Advanced IME features, handwriting recognition, etc.
3. Roundtrip mappings‚Äîthe ability to recover precisely the same format as an original platform's representation. In particular, the internal structure may have no relation to the internal structure of external keyboard source data, the only goal is functional equivalence. --><!-- Note: During development of this section, it was considered whether the modifier RAlt (= AltGr) should be merged with Option. In the end, they were kept separate, but for comparison across platforms implementers may choose to unify them. --><p>Note that in parts of this document, the format <code>@x</code> is used to indicate the <em>attribute</em> <strong>x</strong>.</p><h3 id="Compatibility_Notice"><a name="compatibility-notice" href="#Compatibility_Notice">Compatibility Notice</a></h3><blockquote>
<p>üëâ Note: CLDR-TC has agreed that the changes required were too extensive to maintain compatibility. For this reason, the DTD used here is <em>not</em> compatible with DTDs from prior versions of CLDR such as v41 and prior.</p>
<p>To process earlier XML files, use the prior DTD and specification, such as v41 found at <a href="https://www.unicode.org/reports/tr35/tr35-66/tr35.html">https://www.unicode.org/reports/tr35/tr35-66/tr35.html</a></p>
</blockquote><h3 id="Accessibility"><a name="accessibility" href="#Accessibility">Accessibility</a></h3><p>Keyboard use can be challenging for individuals with various types of disabilities. For this revision, the committee is not evaluating features or architectural designs for the purpose of improving accessibility. Such consideration could be fruitful for future revisions. However, some points on this topic should be made:</p><ol>
<li>Having an industry-wide standard format for keyboards will enable accessibility software to make use of keyboard data with a reduced dependence on platform-specific knowledge.</li>
<li>Some features, such as multiTap and flicks, have the potential to reduce accessibility and thus should be discouraged. For example, multiTap requires pressing keys at a certain speed, and flicks require a more complex movement (press-and-flick) beyond a simple tap. Alternatively, inclusion of accessible methods of generating the same outputs (for example, simple keys on an additional layer), should be considered.</li>
<li>Public feedback is welcome on any aspects of this document which might hinder accessibility.</li>
</ol><h2 id="Definitions"><a name="definitions" href="#Definitions">Definitions</a></h2><p><strong>Arrangement</strong> is the term used to describe the relative position of the rectangles that represent keys, either physically or virtually. A physical keyboard has a static arrangement while a virtual keyboard may have a dynamic arrangement that changes per language and/or layer. While the arrangement of keys on a keyboard may be fixed, the mapping of those keys may vary.</p><p><strong>Base character:</strong> The character emitted by a particular key when no modifiers are active. In ISO terms, this is group 1, level 1.</p><p><strong>Base map:</strong> A mapping from the positions to the base characters. There is only one base map per layout. The characters on this map can be output without the use of any modifier keys.</p><p><strong>Core keys:</strong> also known as ‚Äúalpha‚Äù block. The primary set of key values on a keyboard that are used for typing the target language of the keyboard. For example, the three rows of letters on a standard US QWERTY keyboard (QWERTYUIOP, ASDFGHJKL, ZXCVBNM) together with the most significant punctuation keys. Usually this equates to the minimal keyset for a language as seen on mobile phone keyboards.
Distinguished from the <strong>frame keys</strong>.</p><p><strong>Dead keys:</strong> These are keys which do not emit normal characters by themselves.  They are so named because to the user, they may appear to be ‚Äúdead,‚Äù i.e., non-functional. However, they do produce a change to the input context. For example, in many Latin keyboards hitting the <code>^</code> dead-key followed by the <code>e</code> key produces <code>√™</code>. The <code>^</code> by itself may be invisible or presented in a special way by the platform.</p><p><strong>Frame keys:</strong> These are keys which do not emit characters and are outside of the area of the <strong>core keys</strong>. These keys include both <strong>modifier</strong> keys, such as Shift or Ctrl, but also include platform specific keys: Fn, IME and layout-switching keys, cursor keys, emoji keys.</p><p><strong>Hardware keyboard:</strong> an input device which has individual keys that are pressed. Each key has a unique identifier and the arrangement doesn't change, even if the mapping of those keys does. Also known as a physical keyboard.</p><!-- **Hardware map:** A mapping between  and layout positions. --><p><strong>Input Method Editor (IME):</strong> a component or program that supports input of large character sets. Typically, IMEs employ contextual logic and candidate UI to identify the Unicode characters intended by the user.</p><!-- **ISO position:** The corresponding position of a key using the ISO layout convention where rows are identified by letters and columns are identified by numbers. For example, "D01" corresponds to the "Q" key on a US keyboard. For the purposes of this document, an ISO layout position is depicted by a one-letter row identifier followed by a two digit column number (like "B03", "E12" or "C00"). The following diagram depicts a typical US keyboard layout superimposed with the ISO layout indicators (it is important to note that the number of keys and their physical placement relative to each-other in this diagram is irrelevant, rather what is important is their logical placement using the ISO convention):

![keyboard layout example showing ISO key numbering](images/keyPositions.png)

One may also extend the notion of the ISO layout to support keys that don't map directly to the diagram above (such as the Android device - see diagram). Per the ISO standard, the space bar is mapped to "A03", so the period and comma keys are mapped to "A02" and "A04" respectively based on their relative position to the space bar. Also note that the "E" row does not exist on the Android keyboard.

![keyboard layout example showing extension of ISO key numbering](images/androidKeyboard.png)

If it becomes necessary in the future, the format could extend the ISO layout to support keys that are located to the left of the "00" column by using negative column numbers "-01", "-02" and so on, or 100's complement "99", "98",... --><p><strong>Key:</strong> A key on a physical keyboard, or a virtual key on an on-screen layout.</p><p><strong>Key code:</strong> The integer code sent to the application on pressing a key.</p><p><strong>Key map:</strong> The basic mapping between hardware or on-screen positions and the output characters for each set of modifier combinations associated with a particular layout. There may be multiple key maps for each layout.</p><p><strong>Keyboard:</strong> A particular arrangement of keys for the inputting of text, such as either a physical or virtual keyboard.</p><p><strong>Keyboard author:</strong> The person or group of people designing and producing a particular keyboard layout designed to support one or more languages. In the context of this specification, that author may be editing the LDML XML file directly or by means of software tools.</p><p><strong>Keyboard layout:</strong> A layout is the overall keyboard configuration for a particular locale. Within a keyboard layout, there is a single base map, one or more key maps and zero or more transforms.</p><p><strong>Layer</strong> is an arrangement of keys on a virtual keyboard. A virtual keyboard is made up of a set of layers. Each layer may have a different key layout, unlike with a physical keyboard, and may not correspond directly to a physical keyboard's modifier keys. A layer is accessed via a switch key. See also virtual keyboard, modifier, switch.</p><p><strong>Long-press key:</strong> also known as a ‚Äúchild key‚Äù. A secondary key that is invoked from a top level key on a software keyboard. Secondary keys typically provide access to variants of the top level key, such as accented variants (a =&gt; √°, √†, √§, √£)</p><p><strong>Modifier:</strong> A key that is held to change the behavior of a hardware keyboard. For example, the "Shift" key allows access to upper-case characters on a US keyboard. Other modifier keys include but are not limited to: Ctrl, Alt, Option, Command and Caps Lock. On a touch layout, keys that appear to be modifier keys should be considered to be layer-switching keys.</p><p><strong>Physical keyboard:</strong> see <strong>Hardware keyboard</strong></p><p><strong>Touch keyboard</strong> is a keyboard that is rendered on a, typically, touch surface. It has a dynamic arrangement and contrasts with a hardware keyboard. This term has many synonyms: software keyboard, SIP (Software Input Panel), virtual keyboard. This contrasts with other uses of the term virtual keyboard as an on-screen keyboard for reference or accessibility data entry.</p><p><strong>Transform:</strong> A transform is an element that specifies a set of conversions from sequences of code points into one (or more) other code points. Transforms may reorder or replace text. They may be used to implement ‚Äúdead key‚Äù behaviors, simple orthographic corrections, and visual (typewriter) type input.</p><p><strong>Virtual keyboard:</strong> see <strong>Touch keyboard</strong></p><h3 id="Escaping"><a name="escaping" href="#Escaping">Escaping</a></h3><p>When explicitly specified, attribute values can contain escaped characters. This specification uses two methods of escaping, the <em>UnicodeSet</em> notation and the <code>\u{...}</code> notation.</p><h3 id="unicodeset-escaping">UnicodeSet Escaping</h3><p>The <em>UnicodeSet</em> notation is described in <a href="tr35.html#Unicode_Sets">UTS #35 section 5.3.3</a> and allows for comprehensive character matching, including by character range, properties, names, or codepoints. Currently, the following attribute values allow <em>UnicodeSet</em> notation:</p><ul>
<li><code>from</code> or <code>before</code> on the <code>&lt;transform&gt;</code> element</li>
<li><code>from</code> or <code>before</code> on the <code>&lt;reorder&gt;</code> element</li>
<li><code>chars</code> on the <a href="#test-element-repertoire"><code>&lt;repertoire&gt;</code></a> test element.</li>
</ul><h3 id="uts18-escaping">UTS18 Escaping</h3><p>The <code>\u{...}</code> notation, a subset of hex notation, is described in <a href="https://www.unicode.org/reports/tr18/#Hex_notation">UTS #18 section 1.1</a>. It can refer to one or multiple individual codepoints. Currently, the following attribute values allow the <code>\u{...}</code> notation:</p><ul>
<li><code>to</code>, <code>longPress</code>, <code>multiTap</code>, and <code>longPressDefault</code> on the <code>&lt;key&gt;</code> element</li>
<li><code>to</code> on the <code>&lt;flick&gt;</code> element</li>
<li><code>from</code> or <code>to</code> on the <code>&lt;transform&gt;</code> element</li>
<li><code>value</code> on the <code>&lt;variable&gt;</code> element</li>
<li><code>to</code> and <code>display</code> on the <code>&lt;display&gt;</code> element</li>
<li><code>baseCharacter</code> on the <code>&lt;displayOptions&gt;</code> element</li>
<li>Some attributes on [Keyboard Test Data](#Keyboard Test Data) subelements</li>
</ul><p>Characters of general category of Combining Mark (M), Control characters (Cc), Format characters (Cf), and whitespace other than space should be encoded using one of the notation above as appropriate.</p><p>Attribute values escaped in this manner are annotated with the <code>&lt;!--@ALLOWS_UESC--&gt;</code> DTD annotation, see <a href="tr35.html#57-dtd-annotations">DTD Annotations</a></p><hr><h2 id="File_and_Dir_Structure"><a name="file-and-directory-structure" href="#File_and_Dir_Structure">File and Directory Structure</a></h2><ul>
<li>New collection of layouts that are prescriptive, and define the common core for a keyboard that can be consumed as data for implementation on different platforms. This collection will be in a different location than the existing CLDR keyboard files under main/keyboards. We should remove the existing data files, but keep the old DTD in the same place for compatibility, and also so that conversion tools can use it to read older files.</li>
<li>New layouts will have version metadata to indicate their spec compliance versi‚Äã‚Äãon number.  For this tech preview, the value used must be <code>techpreview</code>.</li>
</ul><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">conformsTo</span>=<span class="hljs-string">"techpreview"</span>/&gt;</span>
</code></pre><blockquote>
<p><em>Note</em>: Unlike other LDML files, layouts are designed to be used outside of the CLDR source tree.  A new mechanism for referencing the DTD path should ideally be used, such as a URN or FPI. See <a href="https://unicode-org.atlassian.net/browse/CLDR-15505">https://unicode-org.atlassian.net/browse/CLDR-15505</a> for discussion. For this tech preview, a relative path to the dtd will continue to be used as below.  Future versions may give other recommendations.</p>
</blockquote><pre><code class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">keyboard</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">"../dtd/ldmlKeyboard.dtd"</span>&gt;</span>
</code></pre><ul>
<li>The filename of a keyboard .xml file does not have to match the BCP47 primary locale ID, but it is recommended to do so. The CLDR repository may enforce filename consistency.</li>
</ul><h3 id="Extensibility"><a name="extensibility" href="#Extensibility">Extensibility</a></h3><p>For extensibility, the <code>&lt;special&gt;</code> element will be allowed at every nearly every level.</p><p>See <a href="tr35.html#special">Element special</a> in Part 1.</p><hr><h2 id="element-hierarchy">Element Hierarchy</h2><p>This section describes the XML elements in a keyboard layout file, beginning with the top level element <code>&lt;keyboard&gt;</code>.</p><h3 id="Element_Keyboard"><a name="element-keyboard" href="#Element_Keyboard">Element: keyboard</a></h3><p>This is the top level element. All other elements defined below are under this element.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"{locale ID}"</span>&gt;</span>
    {definition of the layout as described by the elements defined below}
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <em>none</em></p>
<p>Children: <a href="#Element_displays">displays</a>, <a href="#Element_import">import</a>, <a href="#Element_info">info</a>, <a href="#Element_keys">keys</a>, <a href="#Element_layers">layers</a>, <a href="#Element_locales">locales</a>, <a href="#Element_names">names</a>, <a href="#Element_settings">settings</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#Element_transforms">transforms</a>, <a href="#Element_variables">variables</a>, <a href="#Element_version">version</a>, <a href="#Element_vkeys">vkeys</a></p>
<p>Occurrence: required, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>conformsTo</code> (required)</p><p>This attribute distinguishes the keyboard from prior versions,
and it also specifies the minimum CLDR version required.</p><p>For purposes of this current draft spec, the value should always be <code>techpreview</code></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> ‚Ä¶&nbsp;<span class="hljs-attr">conformsTo</span>=<span class="hljs-string">"techpreview"</span>/&gt;</span>
</code></pre><p><em>Attribute:</em> <code>locale</code> (required)</p><p>This attribute represents the primary locale of the keyboard using BCP 47 <a href="tr35.html#Canonical_Unicode_Locale_Identifiers">Unicode locale identifiers</a> - for example <code>"el"</code> for Greek. Sometimes, the locale may not specify the base language. For example, a Devanagari keyboard for many languages could be specified by BCP-47 code: <code>"mul-Deva"</code>. For further details, see <a href="#Keyboard_IDs">Keyboard IDs</a>.</p><p><strong>Example</strong> (for illustrative purposes only, not indicative of the real data)</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"ka"</span>&gt;</span>
  ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"fr-CH-t-k0-azerty"</span>&gt;</span>
  ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="Element_locales"><a name="element-locales" href="#Element_locales">Element: locales</a></h3><p>The optional <code>&lt;locales&gt;</code> element allows specifying additional or alternate locales. Denotes intentional support for an extra language, not just that a keyboard incidentally supports a language‚Äôs orthography.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">locales</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"‚Ä¶"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"‚Ä¶"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">locales</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_locale">locale</a></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><h3 id="Element_locale"><a name="element-locale" href="#Element_locale">Element: locale</a></h3><p>The optional <code>&lt;locales&gt;</code> element allows specifying additional or alternate locales. Denotes intentional support for an extra language, not just that a keyboard incidentally supports a language‚Äôs orthography.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"{id}"</span>/&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_locales">locales</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>The <a href="tr35.html#Canonical_Unicode_Locale_Identifiers">BCP 47</a> locale ID of an additional language supported by this keyboard.
Do <em>not</em> include the <code>-k0-</code> subtag for this additional language.</p>
</blockquote><p><strong>Example</strong></p><p>See <a href="#Principles_for_Keyboard_IDs">Principles for Keyboard IDs</a> for discussion and further examples.</p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Pan Nigerian Keyboard--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"mul-Latn-NG-t-k0-panng"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locales</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ha"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ig"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- others ‚Ä¶ --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">locales</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="Element_version"><a name="element-version" href="#Element_version">Element: version</a></h3><p>Element used to keep track of the source data version.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">number</span>=<span class="hljs-string">".."</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>number</code> (required)</p><blockquote>
<p>Must be a [<a href="https://semver.org">SEMVER</a>] compatible version number, such as <code>1.0.0</code></p>
</blockquote><p><em>Attribute:</em> <code>cldrVersion</code> (fixed by DTD)</p><blockquote>
<p>The CLDR specification version that is associated with this data file. This value is fixed and is inherited from the <a href="https://github.com/unicode-org/cldr/tree/main/keyboards/dtd">DTD file</a> and therefore does not show up directly in the XML file.</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"tok"</span>&gt;</span>
    ‚Ä¶
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span> <span class="hljs-attr">number</span>=<span class="hljs-string">"1"</span>/&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="Element_info"><a name="element-info" href="#Element_info">Element: info</a></h3><p>Element containing informative properties about the layout, for displaying in user interfaces etc.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">info</span> [<span class="hljs-attr">author</span>=<span class="hljs-string">"{author}"</span>]
      [<span class="hljs-attr">normalization</span>=<span class="hljs-string">"{form}"</span>]
      [<span class="hljs-attr">layout</span>=<span class="hljs-string">"{hint of the layout}"</span>]
      [<span class="hljs-attr">indicator</span>=<span class="hljs-string">"{short identifier}"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>author</code></p><blockquote>
<p>The <code>author</code> attribute contains the name of the author of the layout file.</p>
</blockquote><p><em>Attribute:</em> <code>normalization</code></p><blockquote>
<p>The <code>normalization</code> attribute describes the intended normalization form of the keyboard layout output. The valid values are <code>NFC</code>, <code>NFD</code> or <code>other</code>.</p>
<p>An example use case is aiding a user to choose among the two same layouts with one outputting characters in the normalization form C and one in the normalization form D.</p>
<p>All keyboards in the CLDR repository will be in <code>NFC</code> or <code>NFD</code> forms.  However, users and implementations may produce and consume other normalization forms or mixed output, use the <code>other</code> value to indicate this case.</p>
<p>When using <code>NFC</code> or <code>NFD</code>, tooling should verify that all possible keystrokes, gestures, and transforms on the keyboard only produce the specified normalization form, producing warnings if not.</p>
</blockquote><p><em>Attribute:</em> <code>layout</code></p><blockquote>
<p>The <code>layout</code> attribute describes the layout pattern, such as QWERTY, DVORAK, INSCRIPT, etc. typically used to distinguish various layouts for the same language.</p>
</blockquote><p><em>Attribute:</em> <code>indicator</code></p><blockquote>
<p>The <code>indicator</code> attribute describes a short string to be used in currently selected layout indicator, such as US, SI9 etc.
Typically, this is shown on a UI element that allows switching keyboard layouts and/or input languages.</p>
</blockquote><hr><h3 id="Element_names"><a name="element-names" href="#Element_names">Element: names</a></h3><p>Element used to store any names given to the layout.</p><p>These names are not currently localized.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>
    {set of name elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_name">name</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: required, single</p>
</small>
</blockquote><h3 id="Element_name"><a name="element-name" href="#Element_name">Element: name</a></h3><p>A single name given to the layout.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">value</span>=<span class="hljs-string">".."</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_names">names</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>value</code> (required)</p><blockquote>
<p>The name of the layout.</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"bg-t-k0-phonetic-trad"</span>&gt;</span>
    ‚Ä¶
    <span class="hljs-tag">&lt;<span class="hljs-name">names</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">name</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Bulgarian (Phonetic Traditional)"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">names</span>&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="Element_settings"><a name="element-settings" href="#Element_settings">Element: settings</a></h3><p>An element used to keep track of layout specific settings. This element may or may not show up on a layout. These settings reflect the normal practice by the implementation. However, an implementation using the data may customize the behavior.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span> [<span class="hljs-attr">fallback</span>=<span class="hljs-string">"omit"</span>] [<span class="hljs-attr">transformFailure</span>=<span class="hljs-string">"omit"</span>] [<span class="hljs-attr">transformPartial</span>=<span class="hljs-string">"hide"</span>] /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>fallback="omit"</code></p><blockquote>
<p>The presence of this attribute means that when a modifier key combination goes unmatched, no output is produced. The default behavior (when this attribute is not present) is to fall back to the base map when the modifier key combination goes unmatched.</p>
</blockquote><p>If this attribute is present, it must have a value of omit.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"bg"</span>&gt;</span>
    ‚Ä¶
    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span> <span class="hljs-attr">fallback</span>=<span class="hljs-string">"omit"</span> /&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>Indicates that:</p><ol>
<li>When a modifier combination goes unmatched, do not output anything when a key is pressed.</li>
<li>If a transform is escaped, output the contents of the buffer.</li>
<li>During a transform, hide the contents of the buffer as the user is typing.</li>
</ol><hr><h3 id="Element_keys"><a name="element-keys" href="#Element_keys">Element: keys</a></h3><p>This element defines the properties of all possible keys via <a href="#Element_key"><code>&lt;key&gt;</code> elements</a> used in all layouts.
It is a ‚Äúbag of keys‚Äù without specifying any ordering or relation between the keys.
There is only a single <code>&lt;keys&gt;</code> element in each layout.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> ‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> ‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> ‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> ‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> ‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> ‚Ä¶ /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
</code></pre><p><code>key</code> and <code>flicks</code> elements may be interleaved in any order.</p><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a>
Children: <a href="#Element_key">key</a>, <a href="#Element_flicks">flicks</a>
Occurrence: optional, single</p>
</small>
</blockquote><hr><h3 id="Element_key"><a name="element-key" href="#Element_key">Element: key</a></h3><p>This element defines a mapping between an abstract key and its output. This element must have the <code>keys</code> element as its parent. The <code>key</code> element is referenced by the <code>keys=</code> attribute of the <a href="#Element_row"><code>row</code> element</a>.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span>
 <span class="hljs-attr">id</span>=<span class="hljs-string">"{key id}"</span>
 [<span class="hljs-attr">flicks</span>=<span class="hljs-string">"{flicks identifier}"</span>]
 [<span class="hljs-attr">gap</span>=<span class="hljs-string">"true"</span>]
 [<span class="hljs-attr">longPress</span>=<span class="hljs-string">"{long press keys}"</span>]
 [<span class="hljs-attr">longPressDefault</span>=<span class="hljs-string">"{default longpress target}"</span>]
 [<span class="hljs-attr">multiTap</span>=<span class="hljs-string">"{the output on subsequent taps}"</span>]
 [<span class="hljs-attr">stretch</span>=<span class="hljs-string">"true"</span>]
 [<span class="hljs-attr">switch</span>=<span class="hljs-string">"{layer id}"</span>]
 [<span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span>]
 [<span class="hljs-attr">transform</span>=<span class="hljs-string">"no"</span>]
 [<span class="hljs-attr">width</span>=<span class="hljs-string">"{key width}"</span>]
 /&gt;</span><span class="hljs-comment">&lt;!-- {Comment to improve readability (if needed)} --&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keys">keys</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: optional, multiple
</small></p>
</blockquote><p><strong>Note</strong>: The <code>id</code> attribute is required.</p><p><strong>Note</strong>: <em>at least one of</em> <code>switch</code>, <code>gap</code>, or <code>to</code> are required.</p><p><em>Attribute:</em> <code>id</code></p><blockquote>
<p>The <code>id</code> attribute uniquely identifies the key. NMTOKEN, restricted to <code>[a-zA-Z0-9_.-]</code>. It can (but needn't be) the Latin key name for a Latn script keyboard (a, b, c, A, B, C, ‚Ä¶), or any other valid token (e-acute, alef, alif, alpha, ‚Ä¶)</p>
</blockquote><p><em>Attribute:</em> <code>flicks="flick-id"</code> (optional)</p><blockquote>
<p>The <code>flicks</code> attribute indicates that this key makes use of a <a href="#Element_flicks"><code>flicks</code></a> set with the specified id.</p>
</blockquote><p><em>Attribute:</em> <code>gap="true"</code> (optional)</p><blockquote>
<p>The <code>gap</code> attribute indicates that this key does not have any appearance, but represents a "gap" of the specified number of key widths. Can be used with <code>width</code> to set a width.</p>
</blockquote><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mediumgap"</span> <span class="hljs-attr">gap</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"1.5"</span>/&gt;</span>
</code></pre><p><em>Attribute:</em> <code>longPress="a b c"</code> (optional)</p><blockquote>
<p>The <code>longPress</code> attribute contains any characters that can be emitted by "long-pressing" a key, this feature is prominent in mobile devices. The possible sequences of characters that can be emitted are whitespace delimited. Control characters, combining marks and whitespace (which is intended to be a long-press option) in this attribute are escaped using the <code>\u{...}</code> notation.</p>
</blockquote><p><em>Attribute:</em> <code>longPressDefault</code> (optional)</p><blockquote>
<p>Indicates which of the <code>longPress</code> target characters is the default long-press target, which could be different than the first element. Ignored if not in the <code>longPress</code> list. Characters in this attribute can be escaped using the <code>\u{...}</code> notation.
For example, if the <code>longPressDefault</code> is a key whose <a href="#Element_displays">display</a> appears as <code>{</code> an implementation might render the key as follows:</p>
<p><img src="images/keycapHint.png" alt="keycap hint"></p>
</blockquote><p><em>Attribute:</em> <code>multiTap</code> (optional)</p><blockquote>
<p>A space-delimited list of strings, where each successive element of the list is produced by the corresponding number of quick taps. For example, three taps on the key C01 will produce a ‚Äúc‚Äù in the following example (first tap produces ‚Äúa‚Äù, two taps produce ‚Äúbb‚Äù etc.).</p>
<blockquote>
</blockquote>
<p><em>Example:</em></p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">multiTap</span>=<span class="hljs-string">"bb c d"</span>&gt;</span>
</code></pre>
<p>Control characters, combining marks and whitespace (which is intended to be a multiTap option) in this attribute are escaped using the <code>\u{...}</code> notation.</p>
</blockquote><p><strong>Note</strong>: Behavior past the end of the multiTap list is implementation specific.</p><p><em>Attribute:</em> <code>stretch="true"</code> (optional)</p><blockquote>
<p>The <code>stretch</code> attribute indicates that a touch layout may stretch this key to fill available horizontal space on the row.
This is used, for example, on the spacebar. Note that <code>stretch=</code> is ignored for hardware layouts.</p>
</blockquote><p><em>Attribute:</em> <code>switch="shift"</code> (optional)</p><blockquote>
<p>The <code>switch</code> attribute indicates that this key switches to another <code>layer</code> with the specified id (such as <code>&lt;layer id="shift"/&gt;</code> in this example).
Note that a key may have both a <code>switch=</code> and a <code>to=</code> attribute, indicating that the key outputs prior to switching layers.
Also note that <code>switch=</code> is ignored for hardware layouts: their shifting is controlled via
the modifier keys.</p>
<p>This attribute is an NMTOKEN, restricted to <code>[a-zA-Z0-9-]</code></p>
</blockquote><p><em>Attribute:</em> <code>to</code></p><blockquote>
<p>The <code>to</code> attribute contains the output sequence of characters that is emitted when pressing this particular key. Control characters, whitespace (other than the regular space character) and combining marks in this attribute are escaped using the <code>\u{...}</code> notation. More than one key may output the same output.</p>
</blockquote><blockquote>
<p>The <code>to</code> attribute may also contain the <code>\m{‚Ä¶}</code> syntax to insert a marker. See the definition of <a href="#markers">markers</a>.</p>
</blockquote><p><em>Attribute:</em> <code>transform="no"</code> (optional)</p><blockquote>
<p>The <code>transform</code> attribute is used to define a key that does not participate in a transform (until the next keystroke). This attribute value must be <code>no</code> if the attribute is present.
This attribute is useful where it is desired to output where two different keys could output the same characters (with different key or modifier combinations) but only one of them is intended to participate in a transform.
When the next keystroke is pressed, the prior output may then combine using other transforms.</p>
<p>Note that a more flexible way of solving this problem may be to use special markers which would inhibit matching.</p>
<p>For example, suppose there are the following keys, their output and one transform:</p>
</blockquote><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"X"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span> <span class="hljs-attr">transform</span>=<span class="hljs-string">"no"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"OptX"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> ‚Ä¶&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"^e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√™"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><ul>
<li><strong>X</strong> outputs <code>^</code> (caret)</li>
<li>Option-<strong>X</strong> outputs <code>^</code> but is intended to be the first part of a transform.</li>
<li>Option-<strong>X</strong> + <code>e</code> ‚Üí <code>√™</code></li>
</ul><blockquote>
<p>Without the <code>transform="no"</code> on the base key <strong>X</strong>, it would not be possible to
type the sequence <code>^e</code> (caret+e) as it would turn into <code>√™</code> per the transform.
However, since there is <code>transform="no</code>" on <strong>X</strong>, if the user types <strong>X</strong> + <code>e</code> the sequence remains <code>^e</code>.</p>
</blockquote><ul>
<li><strong>X</strong> + <code>e</code> ‚Üí <code>^e</code></li>
</ul><blockquote>
<p>Using markers, the same results can be obtained without need of <code>transform="no"</code> using:</p>
</blockquote><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"X"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^\m{no_transform}"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"OptX"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> ‚Ä¶&gt;</span>
    <span class="hljs-comment">&lt;!-- this wouldn't match the key X output because of the marker --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"^e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√™"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p>Even better is to use a marker to indicate where transforms are desired:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"X"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"OptX"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^\m{transform}"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> ‚Ä¶&gt;</span>
    <span class="hljs-comment">&lt;!-- again, this wouldn't match the key X output because of the missing marker --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"^\m{transform}e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√™"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p><em>Attribute:</em> <code>width="1.2"</code> (optional, default "1.0")</p><blockquote>
<p>The <code>width</code> attribute indicates that this key has a different width than other keys, by the specified number of key widths.</p>
</blockquote><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"wide-a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"1.2"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"wide-gap"</span> <span class="hljs-attr">gap</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"2.5"</span>/&gt;</span>
</code></pre><h5 id="implied-keys">Implied Keys</h5><p>Not all keys need to be listed explicitly.  The following two can be assumed to already exist:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"gap"</span> <span class="hljs-attr">gap</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"space"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">" "</span> <span class="hljs-attr">stretch</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"1"</span>/&gt;</span>
</code></pre><p>In addition, these 62 keys, comprising 10 digit keys, 26 Latin lower-case keys, and 26 Latin upper-case keys, where the <code>id</code> is the same as the <code>to</code>, are assumed to exist:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"0"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"0"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"2"</span>/&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"A"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"B"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"B"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"C"</span>/&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"b"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"b"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"c"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"c"</span>/&gt;</span>
‚Ä¶
</code></pre><p>These implied keys are available in a data file named <code>keyboards/import/keys-Latn-implied.xml</code> in the CLDR distribution for the convenience of implementations.</p><p>Thus, the implied keys behave as if the following import were present.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">base</span>=<span class="hljs-string">"cldr"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"techpreview/keys-Latn-implied.xml"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p><strong>Note:</strong> All implied keys may be overridden, as with all other imported data items. See the <a href="#Element_import"><code>import</code></a> element for more details.</p><hr><h4 id="Element_flicks"><a name="elements-flicks-flick" href="#Element_flicks">Elements: flicks, flick</a></h4><p>The <code>flicks</code> element is used to generate results from a "flick" of the finger on a mobile device.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">flicks</span>=<span class="hljs-string">"a-flicks"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a-flicks"</span>&gt;</span>
    {a set of flick elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">flicks</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keys">keys</a></p>
<p>Children: <a href="#Element_flick">flick</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>The <code>id</code> attribute identifies the flicks. It can be any NMTOKEN matching <code>[A-Za-z0-9][A-Za-z0-9-]*</code>
The <code>flicks</code> do not share a namespace with the <code>key</code>s, so it would also be allowed
to have <code>&lt;key id="a" flicks="a"/&gt;&lt;flicks id="a"/&gt;</code></p>
</blockquote><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">flick</span> <span class="hljs-attr">directions</span>=<span class="hljs-string">"{list of directions}"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_flicks">flicks</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>directions</code> (required)</p><blockquote>
<p>The <code>directions</code> attribute value is a space-delimited list of keywords, that describe a path, currently restricted to the cardinal and intercardinal directions <code>{n e s w ne nw se sw}</code>.</p>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>The to attribute value is the result of (one or more) flicks.</p>
</blockquote><p><strong>Example</strong>
where a flick to the Northeast then South produces two code points.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">flicks</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">flick</span> <span class="hljs-attr">directions</span>=<span class="hljs-string">"ne s"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\uABCD\uDCBA"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">flicks</span>&gt;</span>
</code></pre><hr><h3 id="Element_import"><a name="element-import" href="#Element_import">Element: import</a></h3><p>The <code>import</code> element is used to reference another xml file so that elements are imported from
another file. The use case is to be able to import a standard set of vkeys, transforms, and similar
from the CLDR repository.  <code>&lt;import&gt;</code> is not recommended as a way for keyboard authors to
split up their keyboard into multiple files, as the intent is for each single XML file to contain all that is needed for a keyboard layout.</p><p><code>&lt;import&gt;</code> can be used as a child of a number of elements (see the <em>Parents</em> section immediately below). Multiple <code>&lt;import&gt;</code> elements may be used, however, <code>&lt;import&gt;</code> elements must come before any other sibling elements.
If two identical elements are defined, the later element will take precedence, that is, override.</p><p><strong>Note:</strong> imported files do not have any indication of their normalization mode. For this reason, the keyboard author must verify that the imported file is of a compatible normalization mode. See the <a href="#Element_info"><code>info</code> element</a> for further details.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">base</span>=<span class="hljs-string">"cldr"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"techpreview/keys-Zyyy-punctuation.xml"</span>/&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_displays">displays</a>, <a href="#Element_keyboard">keyboard</a>, <a href="#Element_keys">keys</a>, <a href="#Element_layers">layers</a>, <a href="#Element_names">names</a>, <a href="#Element_reorders">reorders</a>, <a href="#Element_transformGroup">transformGroup</a>, <a href="#Element_transforms">transforms</a>, <a href="#Element_variables">variables</a>, <a href="#Element_vkeys">vkeys</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>base</code></p><blockquote>
<p>The base may be omitted (indicating a local import) or have the value <code>"cldr"</code>.</p>
</blockquote><p><strong>Note:</strong> <code>base="cldr"</code> is required for all <code>&lt;import&gt;</code> statements within keyboard files in the CLDR repository.</p><p><em>Attribute:</em> <code>path</code> (required)</p><blockquote>
<p>If <code>base</code> is <code>cldr</code>, then the <code>path</code> must start with a CLDR version (such as <code>techpreview</code>) representing the CLDR version to pull imports from. The imports are located in the <code>keyboard/import</code> subdirectory of the CLDR source repository.
If <code>base</code> is omitted, then <code>path</code> is an absolute or relative file path.</p>
</blockquote><p><strong>Further Examples</strong></p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- in a keyboard xml file--&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">base</span>=<span class="hljs-string">"cldr"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"techpreview/transforms-example.xml"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"` "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"^ "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
‚Ä¶


<span class="hljs-comment">&lt;!-- contents of transforms-example.xml --&gt;</span>
<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">transforms</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">"../dtd/ldmlKeyboard.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transforms</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- begin imported part--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√†"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√®"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`i"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√¨"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`o"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√≤"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`u"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√π"</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- end imported part --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p><strong>Note:</strong> The DOCTYPE and root element, here <code>transforms</code>, is the same as
the <em>parent</em> of the <code>&lt;import/&gt;</code> element. It is an error to import an XML file
whose root element is different than the parent element of the <code>&lt;import/&gt;</code> element.</p><p>After loading, the above example will be the equivalent of the following.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- begin imported part--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√†"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√®"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`i"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√¨"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`o"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√≤"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"`u"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√π"</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- end imported part --&gt;</span>

    <span class="hljs-comment">&lt;!-- this line is after the import --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"^ "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"^"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"` "</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"`"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><hr><h3 id="Element_displays"><a name="element-displays" href="#Element_displays">Element: displays</a></h3><p>The displays can be used to describe what is to be displayed on the keytops for various keys. For the most part, such explicit information is unnecessary since the <code>@to</code> element from the <code>keys/key</code> element can be used. But there are some characters, such as diacritics, that do not display well on their own and so explicit overrides for such characters can help.
Another useful scenario is where there are doubled diacritics, or multiple characters with spacing issues.</p><p>The <code>displays</code> consists of a list of display subelements.</p><p><code>displays</code> elements are designed to be shared across many different keyboard layout descriptions, and imported with <code>&lt;import&gt;</code> where needed.</p><p>For combining characters, U+25CC <code>‚óå</code> is used as a base. It is an error to use a combining character without a base in the <code>display</code> attribute.</p><p>For example, a key which outputs a combining tilde (U+0303) can be represented as follows:</p><pre><code class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u0303"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"‚óåÃÉ"</span> /&gt;</span>  <span class="hljs-comment">&lt;!-- \u25CC \u0303--&gt;</span>
</code></pre><p>This way, a key which outputs a combining tilde (U+0303) will be represented as <code>‚óåÃÉ</code> (a tilde on a dotted circle).</p><p>Some scripts/languages may prefer a different base than U+25CC.
See  <a href="#Element_displayOptions"><code>&lt;displayOptions baseCharacter=‚Ä¶/&gt;</code></a>.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">displays</span>&gt;</span>
    {a set of display elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">displays</span>&gt;</span>
</code></pre><p><strong>Note</strong>: There is currently no way to indicate a custom display for a key without output (i.e. without a <code>to=</code> attribute), nor is there a way to indicate that such a key has a standardized identity (e.g. that a key should be identified as a ‚ÄúShift‚Äù). These may be addressed in future versions of this standard.</p><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_display">display</a>, <a href="#Element_displayOptions">displayOptions</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><hr><h3 id="Element_display"><a name="element-display" href="#Element_display">Element: display</a></h3><p>The <code>display</code> element describes how a character, that has come from a <code>keys/key</code> element, should be displayed on a keyboard layout where such display is possible.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{the output}"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"{show as}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_displays">displays</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><p>One of the <code>to</code> or <code>id</code> attributes is required.</p><p><em>Attribute:</em> <code>to</code> (optional)</p><blockquote>
<p>Specifies the character or character sequence from the <code>keys/key</code> element that is to have a special display.
This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.
The <code>to</code> attribute may also contain the <code>\m{‚Ä¶}</code> syntax to reference a marker. See <a href="#markers">Markers</a>. Implementations may highlight a displayed marker, such as with a lighter text color, or a yellow highlight.</p>
</blockquote><p><em>Attribute:</em> <code>id</code> (optional)</p><blockquote>
<p>Specifies the <code>key</code> id. This is useful for keys which do not produce any output (no <code>to=</code> value), such as a shift key.</p>
<p>This attribute must match <code>[A-Za-z0-9][A-Za-z0-9-]*</code></p>
</blockquote><p><em>Attribute:</em> <code>display</code> (required)</p><blockquote>
<p>Required and specifies the character sequence that should be displayed on the keytop for any key that generates the <code>@to</code> sequence or has the <code>@id</code>. (It is an error if the value of the <code>display</code> attribute is the same as the value of the <code>to</code> attribute, this would be an extraneous entry.)</p>
</blockquote><p>This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keys</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">longpress</span>=<span class="hljs-string">"\u0301 \u0300"</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shift"</span> <span class="hljs-attr">switch</span>=<span class="hljs-string">"shift"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">keys</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displays</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u0300"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"Àã"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- \u02CB --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u0301"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"Àä"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- \u02CA --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"shift"</span>  <span class="hljs-attr">display</span>=<span class="hljs-string">"‚á™"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- U+21EA --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\m{grave}"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"`"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- Display \m{grave} as ` --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">displays</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>To allow <code>displays</code> elements to be shared across keyboards, there is no requirement that <code>@to</code> in a <code>display</code> element matches any <code>@to</code>/<code>@id</code> in any <code>keys/key</code> element in the keyboard description.</p><hr><h3 id="Element_displayOptions"><a name="element-displayoptions" href="#Element_displayOptions">Element: displayOptions</a></h3><p>The <code>displayOptions</code> is an optional singleton element providing additional settings on this <code>displays</code>.  It is structured so as to provide for future flexibility in such options.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">displays</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">display</span> ‚Ä¶/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">displayOptions</span> <span class="hljs-attr">baseCharacter</span>=<span class="hljs-string">"x"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">displays</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_displays">displays</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p><em>Attribute:</em> <code>baseCharacter</code> (optional)</p><p><strong>Note:</strong> At present, this is the only option settable in the <code>displayOptions</code>.</p><blockquote>
<p>Some scripts/languages may prefer a different base than U+25CC.
For Lao for example, <code>x</code> is often used as a base instead of <code>‚óå</code>.
Setting <code>baseCharacter="x"</code> (for example) is a <em>hint</em> to the implementation which
requests U+25CC to be substituted with <code>x</code> on display.
As a hint, the implementation may ignore this option.</p>
<p><strong>Note</strong> that not all base characters will be suitable as bases for combining marks.</p>
</blockquote><p>This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.</p><hr><h3 id="Element_forms"><a name="element-forms" href="#Element_forms">Element: forms</a></h3><p>This element represents a set of <code>form</code> elements which define the layout of a particular hardware form.</p><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="#Element_form">form</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p><em><strong>Syntax</strong></em></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">forms</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"iso"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- ... --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"us"</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- ... --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">forms</span>&gt;</span>
</code></pre><hr><h3 id="Element_form"><a name="element-form" href="#Element_form">Element: form</a></h3><p>This element represents a specific <code>form</code> element which defines the layout of a particular hardware form.</p><blockquote>
<p><em>Note:</em> Most keyboards will not need to use this element directly, and the CLDR repository will not accept keyboards which define a custom <code>form</code> element.  This element is provided for two reasons:</p>
</blockquote><ol>
<li><p>To formally specify the standard hardware arrangements used with CLDR for implementations. Implementations can verify the arrangement, and validate keyboards against the number of rows and the number of keys per row.</p>
</li>
<li><p>To allow a way to customize the scancode layout for keyboards not intended to be included in the common CLDR repository.</p>
</li>
</ol><p>See <a href="#implied-form-values">Implied Form Values</a>, below.</p><blockquote>
<small>

<p>Parents: <a href="#Element_forms">forms</a></p>
<p>Children: <a href="#Element_scanCodes">scanCodes</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>This attribute specifies the form id. The value may not be <code>touch</code>.</p>
</blockquote><p><em><strong>Syntax</strong></em></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"us"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scanCodes</span> <span class="hljs-attr">codes</span>=<span class="hljs-string">"00 01 02"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">scanCodes</span> <span class="hljs-attr">codes</span>=<span class="hljs-string">"03 04 05"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre><h5 id="implied-form-values">Implied Form Values</h5><p>There is an implied set of <code>&lt;form&gt;</code> elements corresponding to the default forms, thus implementations must behave as if there was the following import statement:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">forms</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">base</span>=<span class="hljs-string">"cldr"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"techpreview/scanCodes-implied.xml"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- the version will match the current conformsTo of the file --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">forms</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><p>Here is a summary of the implied form elements. Keyboards included in the CLDR Repository must only use these <code>form=</code> values and may not override the scanCodes.</p><blockquote>
<ul>
<li><code>touch</code> - Touch (non-hardware) layout.</li>
<li><code>abnt2</code> - Brazilian 103 key ABNT2 layout (iso + extra key near right shift)</li>
<li><code>iso</code> - European 102 key layout (extra key near left shift)</li>
<li><code>jis</code> - Japanese 109 key layout</li>
<li><code>us</code> - ANSI 101 key layout</li>
</ul>
</blockquote><hr><h3 id="Element_scanCodes"><a name="element-scancodes" href="#Element_scanCodes">Element: scanCodes</a></h3><p>This element represents a keyboard row, and defines the scan codes for the non-frame keys in that row.</p><blockquote>
<small>

<p>Parents: <a href="#Element_form">form</a></p>
<p>Children: none</p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><blockquote>
<p><em>Attribute:</em> <code>codes</code> (required)</p>
</blockquote><blockquote>
<p>The <code>codes</code> attribute is a space-separated list of 2-digit hex bytes, each representing a scan code.</p>
</blockquote><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">scanCodes</span> <span class="hljs-attr">codes</span>=<span class="hljs-string">"29 02 03 04 05 06 07 08 09 0A 0B 0C 0D"</span> /&gt;</span>
</code></pre><hr><h3 id="Element_layers"><a name="element-layers" href="#Element_layers">Element: layers</a></h3><p>This element represents a set of <code>layer</code> elements with a specific physical form factor, whether
hardware or touch layout.</p><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="#Element_layer">layer</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><ul>
<li>At least one <code>layers</code> element is required.</li>
</ul><p><em>Attribute:</em> <code>form</code> (required)</p><blockquote>
<p>This attribute specifies the physical layout of a hardware keyboard,
or that the form is a <code>touch</code> layout.</p>
<p>It is recommended to always have at least one hardware (non-touch) form.
If there is no <code>hardware</code> form, the implementation may need
to choose a different keyboard file, or use some other fallback behavior when using a
hardware keyboard.</p>
<p>Multiple <code>&lt;layers form="touch"&gt;</code> elements are allowed with distinct <code>minDeviceWidth</code> values.
At most one hardware (non-<code>touch</code>) <code>&lt;layers&gt;</code> element is allowed. If a different key arrangement is desired between, for example, <code>us</code> and <code>iso</code> formats, these should be separated into two different keyboards.</p>
<p>The typical keyboard author will be designing a keyboard based on their circumstances and the hardware that they are using. So, for example, if they are in South East Asia, they will almost certainly be using an 101 key hardware keyboard with US key caps. So we want them to be able to reference that (<code>&lt;layers form="us"&gt;</code>) in their design, rather than having to work with an unfamiliar form.</p>
<p>A mismatch between the hardware layout in the keyboard file, and the actual hardware used by the user could result in some keys being inaccessible to the user if their hardware cannot generate the scancodes corresponding to the layout specified by the <code>form=</code> attribute. Such keys could be accessed only via an on-screen keyboard utility. Conversely, a user with hardware keys that are not present in the specified <code>form=</code> will result in some hardware keys which have no function when pressed.</p>
<p>When using an on-screen keyboard, if there is not a <code>&lt;layers form="touch"&gt;</code>
element, the hardware elements can be used for on-screen use.</p>
<p>The value of the <code>form=</code> attribute may be <code>touch</code>, or correspond to a <code>form</code> element. See <a href="#element-form"><code>form</code></a>.</p>
</blockquote><p><em>Attribute:</em> <code>minDeviceWidth</code></p><blockquote>
<p>This attribute specifies the minimum required width, in millimeters (mm), of the touch surface.  The <code>layers</code> entry with the greatest matching width will be selected. This attribute is intended for <code>form="touch"</code>, but is supported for hardware forms.</p>
<p>This must be a whole number between 1 and 999, inclusive.</p>
</blockquote><h3 id="Element_layer"><a name="element-layer" href="#Element_layer">Element: layer</a></h3><p>A <code>layer</code> element describes the configuration of keys on a particular layer of a keyboard. It contains one or more <code>row</code> elements to describe which keys exist in each row.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">layer</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"layerId"</span> <span class="hljs-attr">modifier</span>=<span class="hljs-string">"{Set of Modifier Combinations}"</span>&gt;</span>
    ...
<span class="hljs-tag">&lt;/<span class="hljs-name">layer</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_row">row</a>, <a href="tr35.html#special"><em>special</em></a></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute</em> <code>id</code> (required for <code>touch</code>)</p><blockquote>
<p>The <code>id</code> attribute identifies the layer for touch layouts.  This identifier specifies the layout as the target for layer switching, as specified by the <code>switch=</code> attribute on the <a href="#Element_key"><code>&lt;key&gt;</code></a> element.
Touch layouts must have one <code>layer</code> with <code>id="base"</code> to serve as the base layer.</p>
<p>Must match <code>[A-Za-z0-9][A-Za-z0-9-]*</code></p>
</blockquote><p><em>Attribute:</em> <code>modifier</code> (required for <code>hardware</code>)</p><blockquote>
<p>This has two roles. It acts as an identifier for the <code>layer</code> element for hardware keyboards (in the absence of the id= element) and also provides the linkage from the hardware modifiers into the correct <code>layer</code>.</p>
<p>To indicate that no modifiers apply, the reserved name of <code>none</code> can be used.
The following modifier components can be used, separated by spaces.
Note that <code>L</code> or <code>R</code> indicates a left- or right- side modifier only (such as <code>altL</code>)
whereas <code>alt</code> indicates <em>either</em> left or right alt key.
<code>shift</code> also indicates either shift key.</p>
<ul>
<li><code>none</code> (no modifier, may not be combined with others)</li>
<li><code>alt</code></li>
<li><code>altL</code></li>
<li><code>altR</code></li>
<li><code>caps</code></li>
<li><code>ctrl</code></li>
<li><code>ctrlL</code></li>
<li><code>ctrlR</code></li>
<li><code>shift</code></li>
</ul>
<p>Note that <code>alt</code> is sometimes referred to as <em>opt</em> or <em>option</em>.</p>
<p>Left- and right- side modifiers (such as <code>"altL ctrlR"</code> or <code>"altL altR"</code>) should not be used together in a single <code>modifier</code> attribute value.</p>
<p>Left- and right- side modifiers (such as <code>"altL ctrlR"</code> or <code>"altL altR"</code>) should not be used together in a single <code>modifier</code> attribute value.</p>
</blockquote><blockquote>
<p>For hardware layouts, the use of <code>@modifier</code> as an identifier for a layer is sufficient since it is always unique among the set of <code>layer</code> elements in a keyboard.</p>
<p>The set of modifiers must match <code>(none|([A-Za-z0-9]+)( [A-Za-z0-9]+)*)</code></p>
</blockquote><hr><h3 id="Element_row"><a name="element-row" href="#Element_row">Element: row</a></h3><p>A <code>row</code> element describes the keys that are present in the row of a keyboard.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"{keyId} {keyId} ‚Ä¶"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_layer">layer</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>keys</code> (required)</p><blockquote>
<p>This is a string that lists the id of <a href="#Element_key"><code>key</code> elements</a> for each of the keys in a row, whether those are explicitly listed in the file or are implied.  See the <code>key</code> documentation for more detail.</p>
<p>For non-<code>touch</code> forms, the number of keys in each row may not exceed the number of scan codes defined for that row, and the number of rows may not exceed the defined number of rows for that form. See <a href="#Element_scanCodes"><code>scanCodes</code></a>;</p>
</blockquote><p><strong>Example</strong></p><p>Here is an example of a <code>row</code> element:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">row</span> <span class="hljs-attr">keys</span>=<span class="hljs-string">"a z e r t y u i o p caret dollar"</span> /&gt;</span>
</code></pre><hr><h3 id="Element_vkeys"><a name="element-vkeys" href="#Element_vkeys">Element: vkeys</a></h3><p>On some architectures, applications may directly interact with keys before they are converted to characters. The keys are identified using a virtual key identifier or vkey. The mapping between a physical keyboard key and a vkey is keyboard-layout dependent. For example, a French keyboard would identify the top-left key (ISO D01) as being an <code>A</code> with a vkey of <code>A</code> as opposed to <code>Q</code> on a US English keyboard. While vkeys are layout dependent, they are not modifier dependent. A shifted key always has the same vkey as its unshifted counterpart. In effect, a key may be identified by its vkey and the modifiers active at the time the key was pressed.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span>&gt;</span>
    {a set of vkey elements}
<span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#Element_vkey">vkey</a></p>
<p>Occurrence: optional, single</p>
</small>
</blockquote><p>There is at most a single vkeys element per keyboard.</p><p>A <code>vkeys</code> element consists of a list of <code>vkey</code> elements.</p><hr><h3 id="Element_vkey"><a name="element-vkey" href="#Element_vkey">Element: vkey</a></h3><p>A <code>vkey</code> element describes a mapping between a key and a vkey.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{from}"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{to}"</span> /&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_vkeys">vkeys</a></p>
<p>Children: <em>none</em></p>
<p>Occurrence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>from</code> (required)</p><blockquote>
<p>The vkey being mapped from. See <a href="#CLDR_VKey_Enum">CLDR VKey Enum</a> for a reference table.</p>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><blockquote>
<p>The resultant vkey identifier. See <a href="#CLDR_VKey_Enum">CLDR VKey Enum</a> for a reference table.</p>
</blockquote><p><strong>Example</strong></p><p>This example shows some of the mappings for a French keyboard layout:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">vkeys</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"Q"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"A"</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"W"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Z"</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"A"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"Q"</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">vkey</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"Z"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"W"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">vkeys</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h3 id="Element_variables"><a name="element-variables" href="#Element_variables">Element: variables</a></h3><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#element-string">string</a>, <a href="#element-set">set</a>, <a href="#element-unicodeSet">unicodeSet</a></p>
</small><p><small>Occurrence: optional, single
</small></p>
</blockquote><p>This is a container for variables to be used with <a href="#element-transform">transform</a>, <a href="#element-display">display</a> and <a href="#element-key">key</a> elements.</p><p>Note that the <code>id=</code> attribute must be unique across all children of the <code>variables</code> element.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">variables</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"y"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"yes"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- a simple string--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"upper"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"A B C D E FF"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- a set with 6 items --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"consonants"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[‡§ï‡§∏‡§§‡§®‡§Æ‡§π]"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- a UnicodeSet --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">variables</span>&gt;</span>
</code></pre><hr><h3 id="element-string">Element: string</h3><blockquote>
<small>

<p>Parents: <a href="#Element_variables">variables</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: optional, multiple
</small></p>
</blockquote><blockquote>
<p>This element represents a single string which is used by the <a href="#element-transform">transform</a> elements for string matching and substitution, as well as by the <a href="#element-key">key</a> and <a href="#element-display">display</a> elements.</p>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>Specifies the identifier (name) of this string.
All ids must be unique across all types of variables.</p>
<p><code>id</code> must match <code>[0-9A-Za-z_]{1,32}</code></p>
</blockquote><p><em>Attribute:</em> <code>value</code> (required)</p><blockquote>
<p>Strings may contain whitespaces. However, for clarity, it is recommended to escape spacing marks, even in strings.
This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.
Variables may refer to other string variables if they have been previously defined, using <code>${string}</code> syntax.
<a href="#markers">Markers</a> may be included with the <code>\m{‚Ä¶}</code> notation.</p>
</blockquote><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">variables</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cluster_hi"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"‡§π‡§ø"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- a string --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"zwnj"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"\u{200C}"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- single codepoint --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"acute"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"\m{acute}"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- refer to a marker --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"zwnj_acute"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${zwnj}${acute}"</span>  /&gt;</span> <span class="hljs-comment">&lt;!-- Combine two variables --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"zwnj_sp_acute"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${zwnj}\u{0020}${acute}"</span>  /&gt;</span> <span class="hljs-comment">&lt;!-- Combine two variables --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">variables</span>&gt;</span>
</code></pre><p>These may be then used in multiple contexts:</p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- as part of a regex --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"${cluster_hi}X"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"X"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"Y"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"${cluster_hi}"</span> /&gt;</span>
‚Ä¶
<span class="hljs-comment">&lt;!-- as part of a key bag  --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"hi_key"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"${cluster_hi}"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"acute_key"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"${acute}"</span> /&gt;</span>
‚Ä¶
<span class="hljs-comment">&lt;!-- Display ¬¥ instead of the non-displayable marker --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"${acute}"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"¬¥"</span> /&gt;</span>
</code></pre><hr><h3 id="element-set">Element: set</h3><blockquote>
<small>

<p>Parents: <a href="#Element_variables">variables</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: optional, multiple
</small></p>
</blockquote><blockquote>
<p>This element represents a set of strings used by the <a href="#element-transform">transform</a> elements for string matching and substitution.</p>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>Specifies the identifier (name) of this set.
All ids must be unique across all types of variables.</p>
<p><code>id</code> must match <code>[0-9A-Za-z_]{1,32}</code></p>
</blockquote><p><em>Attribute:</em> <code>value</code> (required)</p><blockquote>
<p>The <code>value</code> attribute is always a set of strings separated by whitespace, even if there is only a single item in the set, such as <code>"A"</code>.
Leading and trailing whitespace is ignored.
This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.
Sets may refer to other string variables if they have been previously defined, using <code>${string}</code> syntax, or to other previously-defined sets using <code>$[set]</code> syntax.
Set references must be separated by whitespace: <code>$[set1]$[set2]</code> is an error; instead use <code>$[set1] $[set2]</code>.
<a href="#markers">Markers</a> may be included with the <code>\m{‚Ä¶}</code> notation.</p>
</blockquote><p><strong>Examples</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">variables</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"upper"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"A B CC D E FF "</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 6 items --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lower"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"a b c  d e  f "</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 6 items --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"upper_or_lower"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$[upper] $[lower]"</span>  /&gt;</span> <span class="hljs-comment">&lt;!-- Concatenate two sets --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lower_or_upper"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"$[lower] $[upper]"</span>  /&gt;</span> <span class="hljs-comment">&lt;!-- Concatenate two sets --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"A"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- Just one element, an 'A'--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"cluster_or_zwnj"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"${hi_cluster} ${zwnj}"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 2 items: "‡§π‡§ø \u${200C}"--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">variables</span>&gt;</span>
</code></pre><p>Match "X" followed by any uppercase letter:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"X$[upper]"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"‚Ä¶"</span> /&gt;</span>
</code></pre><p>Map from upper to lower:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"($[upper])"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"$[1:lower]"</span> /&gt;</span>
</code></pre><p>See <a href="#element-transform">transform</a> for further details.</p><hr><h3 id="element-unicodeset">Element: unicodeSet</h3><blockquote>
<small>

<p>Parents: <a href="#Element_variables">variables</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: optional, multiple
</small></p>
</blockquote><blockquote>
<p>This element represents a set, using a subset of the <a href="tr35.html#Unicode_Sets">UnicodeSet</a> format, used by the <a href="#element-transform"><code>transform</code></a> elements for string matching and substitution.
Note important restrictions on the syntax below.</p>
</blockquote><p><em>Attribute:</em> <code>id</code> (required)</p><blockquote>
<p>Specifies the identifier (name) of this unicodeSet.
All ids must be unique across all types of variables.</p>
<p><code>id</code> must match <code>[0-9A-Za-z_]{1,32}</code></p>
</blockquote><p><em>Attribute:</em> <code>value</code> (required)</p><blockquote>
<p>String value in <a href="tr35.html#Unicode_Sets">UnicodeSet</a> format.
Leading and trailing whitespace is ignored.
Variables may refer to other string variables if they have been previously defined, using <code>${string}</code> syntax, or to other previously-defined UnicodeSets (not sets) using <code>$[unicodeSet]</code> syntax.</p>
</blockquote><p><strong>Syntax Note</strong></p><ul>
<li>Warning: UnicodeSets look superficially similar to regex character classes as used in <a href="#element-transform"><code>transform</code></a> elements, but they are different. UnicodeSets must be defined with a <code>unicodeSet</code> element, and referenced with the <code>$[unicodeSet]</code> notation in transforms. UnicodeSets cannot be specified inline in a transform, and can only be used indirectly by reference to the corresponding <code>unicodeSet</code> element.</li>
<li>Multi-character strings (<code>{}</code>) are not supported, such as <code>[≈ºƒ°ƒß{ie}{gƒß}]</code>.</li>
<li>UnicodeSet property notation (<code>\p{‚Ä¶}</code> or <code>[:‚Ä¶:]</code>) may <strong>NOT</strong> be used, because that would make implementations dependent on a particular version of Unicode. However, implementations and tools may wish to pre-calculate the value of a particular UnicodeSet, and "freeze" it as explicit code points.  The example below of <code>$[KhmrMn]</code> matches all nonspacing marks in the <code>Khmr</code> script.</li>
<li>UnicodeSets may represent a very large number of codepoints. A limit may be set on how many unique range entries may be matched.</li>
</ul><p><strong>Examples</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">variables</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"consonants"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[‡§ï‡§∏‡§§‡§®‡§Æ‡§π]"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- unicode set range --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"range"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[a-z D E F G \u200A]"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- a through z, plus a few others --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"newrange"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[$[range]-[G]]"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- The above range, but not including G --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"KhmrMn"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD]"</span>&gt;</span> <span class="hljs-comment">&lt;!--  [[:Khmr:][:Mn:]] as of Unicode 15.0--&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">variables</span>&gt;</span>
</code></pre><p>The <code>unicodeSet</code> element may not be used as the source or target for mapping operations (<code>$[1:variable]</code> syntax).
The <code>unicodeSet</code> element may not be referenced by <a href="#element-key"><code>key</code></a> and <a href="#element-display"><code>display</code></a> elements.</p><hr><h3 id="Element_transforms"><a name="element-transforms" href="#Element_transforms">Element: transforms</a></h3><p>This element defines a group of one or more <code>transform</code> elements associated with this keyboard layout. This is used to support features such as dead-keys, character reordering, backspace behavior, etc. using a straightforward structure that works for all the keyboards tested, and that results in readable source data.</p><p>There can be multiple <code>&lt;transforms&gt;</code> elements, but only one for each <code>type</code>.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"..."</span>&gt;</span>
    {a set of transform groups}
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_keyboard">keyboard</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#Element_transformGroup">transformGroup</a></p>
<p>Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>type</code> (required)</p><blockquote>
<p>Values: <code>simple</code>, <code>backspace</code></p>
</blockquote><p>There are other keying behaviors that are needed particularly in handing complex orthographies from various parts of the world. The behaviors intended to be covered by the transforms are:</p><ul>
<li>Reordering combining marks. The order required for underlying storage may differ considerably from the desired typing order. In addition, a keyboard may want to allow for different typing orders.</li>
<li>Error indication. Sometimes a keyboard layout will want to specify to the application that a particular keying sequence in a context is in error and that the application should indicate that that particular keypress is erroneous.</li>
<li>Backspace handling. There are various approaches to handling the backspace key. An application may treat it as an undo of the last key input, or it may simply delete the last character in the currently output text, or it may use transform rules to tell it how much to delete.</li>
</ul><h4 id="markers">Markers</h4><p>Markers are placeholders which record some state, but without producing normal visible text output.  They were designed particularly to support dead-keys.</p><p>The marker ID is any valid <code>NMTOKEN</code> (But see <a href="https://unicode-org.atlassian.net/browse/CLDR-17043">CLDR-17043</a> for future discussion.)</p><p>Consider the following abbreviated example:</p><pre><code class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">display</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\m{circ_marker}"</span> <span class="hljs-attr">display</span>=<span class="hljs-string">"^"</span> /&gt;</span>
‚Ä¶
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"circ_key"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\m{circ_marker}"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">key</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"e"</span> /&gt;</span>
‚Ä¶
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\m{circ_marker}e"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"√™"</span> /&gt;</span>
</code></pre><ol>
<li><p>The user presses the <code>circ_key</code> key. The key can be shown with the keycap <code>^</code> due to the <code>&lt;display&gt;</code> element.</p>
</li>
<li><p>The special marker, <code>circ_marker</code>, is added to the end of input context.</p>
<p> The input context does not match any transforms.</p>
<p> The input context has:</p>
<ul>
<li>‚Ä¶</li>
<li>marker <code>circ_marker</code></li>
</ul>
</li>
<li><p>Also due to the <code>&lt;display&gt;</code> element, implementations can opt to display a visible <code>^</code> (perhaps visually distinct from a plain <code>^</code> carat). Implementations may opt to display nothing and only store the marker in the input context.</p>
</li>
<li><p>The user now presses the <code>e</code> key, which is also added to the input context. The input context now has:</p>
<ul>
<li>‚Ä¶</li>
<li>character <code>e</code></li>
<li>marker <code>circ_marker</code></li>
</ul>
</li>
<li><p>Now, the input context matches the transform.  The <code>e</code> and the marker are replaced with <code>√™</code>.</p>
<p> The input context now has:</p>
<ul>
<li>‚Ä¶</li>
<li>character <code>√™</code></li>
</ul>
</li>
</ol><p><strong>Effect of markers on final text</strong></p><p>All markers must be removed before text is returned to the application from the input context.
If the input context changes, such as if the cursor or mouse moves the insertion point somewhere else, all markers in the input context are removed.</p><p><strong>Implementation Notes</strong></p><p>Ideally, markers are implemented entirely out-of-band from the normal text stream. However, implementations <em>may</em> choose to map each marker to a <a href="https://www.unicode.org/glossary/#private_use_character">Unicode private-use character</a> for use only within the implementation‚Äôs processing and temporary storage in the input context.</p><p>For example, the first marker encountered could be represented as U+E000, the second by U+E001 and so on.  If a regex processing engine were used, then those PUA characters could be processed through the existing regex processing engine.  <code>[^\uE000-\uE009]</code> could be used as an expression to match a character that is not a marker, and <code>[Ee]\u{E000}</code> could match <code>E</code> or <code>e</code> followed by the first marker.</p><p>Such implementations must take care to remove all such markers (see prior section) from the resultant text. As well, implementations must take care to avoid conflicts if applications themselves are using PUA characters, such as is often done with not-yet-encoded scripts or characters.</p><hr><h3 id="Element_transformGroup"><a name="element-transformgroup" href="#Element_transformGroup">Element: transformGroup</a></h3><blockquote>
<small>

<p>Parents: <a href="#Element_transforms">transforms</a></p>
<p>Children: <a href="#Element_import">import</a>, <a href="#Element_reorder">reorder</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#Element_transform">transform</a></p>
</small><p><small>Occurrence: optional, multiple
</small></p>
</blockquote><p>A <code>transformGroup</code> represents a set of transform elements or reorder elements.</p><p>Each <code>transformGroup</code> is processed entirely before proceeding to the next one.</p><p>Each <code>transformGroup</code> element, after imports are processed, must have either <a href="#Element_reorder">reorder</a> elements or <a href="#Element_transform">transform</a> elements, but not both. The <code>&lt;transformGroup&gt;</code> element may not be empty.</p><p><strong>Examples</strong></p><h4 id="example-transformgroup-with-transform-elements">Example: <code>transformGroup</code> with <code>transform</code> elements</h4><p>This is a <code>transformGroup</code> that consists of one or more <a href="#element-transform"><code>transform</code></a> elements, prefaced by one or more <code>import</code> elements. See the discussion of those elements for details. <code>import</code> elements in this group may not import <code>reorder</code> elements.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"..."</span>/&gt;</span> <span class="hljs-comment">&lt;!-- optional import elements--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- other &lt;transform/&gt; elements --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><h4 id="example-transformgroup-with-reorder-elements">Example: <code>transformGroup</code> with <code>reorder</code> elements</h4><p>This is a <code>transformGroup</code> that consists of one or more <a href="#element-transform"><code>transform</code></a> elements, optionally prefaced by one or more <code>import</code> elements that import <code>transform</code> elements. See the discussion of those elements for details.</p><p><code>import</code> elements in this group may not import <code>transform</code> elements.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"..."</span>/&gt;</span> <span class="hljs-comment">&lt;!-- optional import elements--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">...</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- other &lt;reorder&gt; elements --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><hr><h3 id="Element_transform"><a name="element-transform" href="#Element_transform">Element: transform</a></h3><p>This element represents a single transform that may be performed using the keyboard layout. A transform is an element that specifies a set of conversions from sequences of code points into (one or more) other code points. For example, in most French keyboards hitting the <code>^</code> dead-key followed by the <code>e</code> key produces <code>√™</code>.</p><p>Matches are processed against the "input context", a temporary buffer containing all relevant text up to the insertion point. If the user moves the insertion point, the input context is discarded and recreated from the application‚Äôs text buffer.  Implementations may discard the input context at any time.</p><p>The input context may contain, besides regular text, any <a href="#markers">Markers</a> as a result of keys or transforms, since the insertion point was moved.</p><p>Using regular expression terminology, matches are done as if there was an implicit <code>$</code> (match end of buffer) at the end of each pattern. In other words, <code>&lt;transform from="ke" ‚Ä¶&gt;</code> will not match an input context ending with <code>‚Ä¶keyboard</code>, but it will match the last two codepoints of an input context ending with <code>‚Ä¶awake</code>.</p><p>All of the <code>transform</code> elements in a <code>transformGroup</code> are tested for a match, in order, until a match is found. Then, the matching element is processed, and then processing proceeds to the <strong>next</strong> <code>transformGroup</code>. If none of the <code>transform</code> elements match, processing proceeds without modification to the buffer to the <strong>next</strong> <code>transformGroup</code>.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{input rule}"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"{output pattern}"</span>/&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_transformGroup">transformGroup</a>
Children: <em>none</em>
Occurrence: required, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>from</code> (required)</p><blockquote>
<p>The <code>from</code> attribute consists of an input rule for matching the input context.</p>
<p>The <code>transform</code> rule and output pattern uses a modified, mostly subsetted, regular expression syntax, with EcmaScript syntax (with the <code>u</code> Unicode flag) as its baseline reference (see <a href="https://developer.mozilla.org/docs/Web/JavaScript/Guide/Regular_Expressions">MDN-REGEX</a>). Differences from regex implementations will be noted.</p>
</blockquote><h4 id="regex-like-syntax">Regex-like Syntax</h4><ul>
<li><p><strong>Simple matches</strong></p>
<p>  <code>abc</code> <code>êíµ</code></p>
</li>
<li><p><strong>Unicode codepoint escapes</strong></p>
<p>  <code>\u1234 \u012A</code>
  <code>\u{22} \u{012a} \u{1234A}</code></p>
<p>  The hex escaping is case insensitive. The value may not match a surrogate or illegal character, nor a marker character.
  The form <code>\u{‚Ä¶}</code> is preferred as it is the same regardless of codepoint length.</p>
</li>
<li><p><strong>Fixed character classes and escapes</strong></p>
<p>  <code>\s \S \t \r \n \f \v \\ \$ \d \w \D \W \0</code></p>
<p>  The value of these classes do not change with Unicode versions.</p>
<p>  <code>\s</code> for example is exactly <code>[\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code></p>
<p>  <code>\\</code> and <code>\$</code> evaluate to <code>\</code> and <code>$</code>, respectively.</p>
</li>
<li><p><strong>Character classes</strong></p>
<p>  <code>[abc]</code> <code>[^def]</code> <code>[a-z]</code> <code>[‡•≤‡§Ñ-‡§Ü‡§á-‡§ã]</code> <code>[\u093F-\u0944\u0962\u0963]</code></p>
<ul>
<li>supported</li>
<li>no Unicode properties such as <code>\p{‚Ä¶}</code></li>
<li>Warning: Character classes look superficially similar to UnicodeSets as defined in <a href="#element-unicodeSet"><code>unicodeSet</code></a> elements, but they are different. UnicodeSets must be defined with a <code>unicodeSet</code> element, and referenced with the <code>$[unicodeSet]</code> notation in transforms. UnicodeSets cannot be used directly in a transform.</li>
</ul>
</li>
<li><p><strong>Bounded quantifier</strong></p>
<p>  <code>{x,y}</code></p>
<p>  <code>x</code> and <code>y</code> are required single digits representing the minimum and maximum number of occurrences.
  <code>x</code> must be ‚â• 0, <code>y</code> must be ‚â• x and ‚â•&nbsp;1</p>
</li>
<li><p><strong>Optional Specifier</strong></p>
<p>  <code>?</code> - equivalent of <code>{0,1}</code></p>
</li>
<li><p><strong>Numbered Capture Groups</strong></p>
<p>  <code>([abc])([def])</code> (up to 9 groups)</p>
<p>  These refer to groups captured as a set, and can be referenced with the <code>$1</code> through <code>$9</code> operators in the <code>to=</code> pattern. May not be nested.</p>
</li>
<li><p><strong>Non-capturing groups</strong></p>
<p>  <code>(?:thismatches)</code></p>
</li>
<li><p><strong>Nested capturing groups</strong></p>
<p>  <code>(?:[abc]([def]))|(?:[ghi])</code></p>
<p>  Capture groups may be nested, however only the innermost group is allowed to be a capture group. The outer group must be a non-capturing group.</p>
</li>
<li><p><strong>Disjunctions</strong></p>
<p>  <code>abc|def</code></p>
<p>  Match either <code>abc</code> or <code>def</code>.</p>
</li>
<li><p><strong>Match a single Unicode codepoint</strong></p>
<p>  <code>.</code></p>
<p>  Matches a codepoint, not individual code units. (See the ‚Äôu‚Äô option in EcmaScript262 regex.)
  For example, Osage <code>êíµ</code> is one match (<code>.</code>) not two.
  Does not match <a href="#markers">markers</a>. (See <code>\m{.}</code> and <code>\m{marker}</code>, below.)</p>
</li>
<li><p><strong>Match the start of the text context</strong></p>
<p>  <code>^</code></p>
<p>  The start of the context could be the start of a line, a grid cell, or some other formatting boundary.
  See description at the top of <a href="#element-transform"><code>transforms</code></a>.</p>
</li>
</ul><h4 id="additional-features">Additional Features</h4><p>The following are additions to standard Regex syntax.</p><ul>
<li><p><strong>Match a Marker</strong></p>
<p>  <code>\m{Some_Marker}</code></p>
<p>  Matches the named marker.
  Also see <a href="#markers">Markers</a>.</p>
</li>
<li><p><strong>Match a single marker</strong></p>
<p>  <code>\m{.}</code></p>
<p>  Matches any single marker.
  Also see <a href="#markers">Markers</a>.</p>
</li>
<li><p><strong>String Variables</strong></p>
<p>  <code>${zwnj}</code></p>
<p>  In this usage, the variable with <code>id="zwnj"</code> will be substituted in at this point in the expression. The variable can contain a range, a character, or any other portion of a pattern. If <code>zwnj</code> is a simple string, the pattern will match that string at this point.</p>
</li>
<li><p><strong>Set and UnicodeSet variables</strong></p>
<p>  <code>$[upper]</code></p>
<p>  Given a space-separated variable, this syntax will match <em>any</em> of the substrings. This expression may be thought of  (and implemented) as if it were a <em>non-capturing group</em>. It may, however, be enclosed within a capturing group. For example, the following definition of <code>$[upper]</code> will match as if it were written <code>(?:A|B|CC|D|E|FF)</code>.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">variables</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"upper"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">" A B CC  D E  FF "</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">variables</span>&gt;</span>
</code></pre>
<p>  This expression in a <code>from=</code> may be used to <strong>insert a mapped variable</strong>, see below under <a href="#replacement-syntax">Replacement syntax</a>.</p>
</li>
</ul><h4 id="disallowed-regex-features">Disallowed Regex Features</h4><ul>
<li><p><strong>Unicode properties</strong></p>
<p>  <code>\p{property}</code> <code>\P{property}</code></p>
<p>  <strong>Rationale:</strong> The behavior of this feature varies by Unicode version, and so would not have predictable results.</p>
<p>  Tooling may choose to suggest an expansion of properties, such as <code>\p{Mn}</code> to all non spacing marks for a certain Unicode version.  As well, a set of variables could be constructed in an <code>import</code>-able file matching particularly useful Unicode properties.</p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">unicodeSet</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Mn"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"[\u034F\u0591-\u05AF\u05BD\u05C4\u05C5\‚Ä¶]"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- 1,985 code points --&gt;</span>
</code></pre>
</li>
<li><p><strong>Backreferences</strong></p>
<p>  <code>([abc])-\1</code> <code>\k&lt;something&gt;</code></p>
<p>  <strong>Rationale:</strong> Implementation and cognitive complexity.</p>
</li>
<li><p><strong>Unbounded Quantifiers</strong></p>
<p>  <code>* + *? +? {1,} {0,}</code></p>
<p>  <strong>Rationale:</strong> Implementation and Computational complexity.</p>
</li>
<li><p><strong>Nested capture groups</strong></p>
<p>  <code>((a|b|c)|(d|e|f))</code></p>
<p>  <strong>Rationale:</strong> Computational and cognitive complexity.</p>
</li>
<li><p><strong>Named capture groups</strong></p>
<p>  <code>(?&lt;something&gt;)</code></p>
<p>  <strong>Rationale:</strong> Implementation complexity.</p>
</li>
<li><p><strong>Assertions</strong> other than <code>^</code></p>
<p>  <code>\b</code> <code>\B</code> <code>(?&lt;!‚Ä¶)</code> ‚Ä¶</p>
<p>  <strong>Rationale:</strong> Implementation complexity.</p>
</li>
<li><p><strong>End marker</strong></p>
<p>  <code>$</code></p>
<p>  The end marker can be thought of as being implicitly at the end of every <code>from=</code> pattern, matching the insertion point. Transforms do not match past the insertion point.</p>
</li>
</ul><p><em>Attribute:</em> <code>to</code></p><blockquote>
<p>This attribute represents the characters that are output from the transform.</p>
<p>If this attribute is absent, it indicates that the no characters are output, such as with a backspace transform.</p>
<p>A final rule such as <code>&lt;transform from=".*"/&gt;</code> will remove all context which doesn‚Äôt match one of the prior rules.</p>
</blockquote><h4 id="replacement-syntax">Replacement syntax</h4><p>Used in the <code>to=</code></p><ul>
<li><p><strong>Literals</strong></p>
<p>  <code>$$ \$ \\</code> = <code>$ $ \</code></p>
</li>
<li><p><strong>Entire matched substring</strong></p>
<p>  <code>$0</code></p>
</li>
<li><p><strong>Insert the specified capture group</strong></p>
<p>  <code>$1 $2 $3 ‚Ä¶&nbsp;$9</code></p>
</li>
<li><p><strong>Insert an entire variable</strong></p>
<p>  <code>${variable}</code></p>
<p>  The entire contents of the named variable will be inserted at this point.</p>
</li>
<li><p><strong>Insert a mapped set</strong></p>
<p>  <code>$[1:variable]</code> (Where "1" is be any numbered capture group from 1 to 9)</p>
<p>  Maps capture group 1 to variable <code>variable</code>. The <code>from=</code> side must also contain a grouped variable. This expression may appear anywhere or multiple times in the <code>to=</code> pattern.</p>
<p>  <strong>Example</strong></p>
<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"upper"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"A B CC D E  FF       G"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">set</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"lower"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"a b c  d e  \u{0192} g"</span> /&gt;</span>
<span class="hljs-comment">&lt;!-- note that values may be spaced for ease of reading --&gt;</span>
‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"($[upper])"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"$[1:lower]"</span> /&gt;</span>
</code></pre>
<ul>
<li><p>The capture group on the <code>from=</code> side <strong>must</strong> contain exactly one set variable.  <code>from="Q($[upper])X"</code> can be used (other context before or after the capture group), but <code>from="(Q$[upper])"</code> may not be used with a mapped variable and is flagged as an error.</p>
</li>
<li><p>The <code>from=</code> and <code>to=</code> sides of the pattern must both be using <code>set</code> variables. There is no way to insert a set literal on either side and avoid using a variable.
  A UnicodeSet may not be used directly, but must be defined as a <code>unicodeSet</code> variable.</p>
</li>
<li><p>The two variables (here <code>upper</code> and <code>lower</code>) must have exactly the same number of whitespace-separated items. Leading and trailing space (such as at the end of <code>lower</code>) is ignored. A variable without any spaces is considered to be a set variable of exactly one item.</p>
</li>
<li><p>As described in <a href="#additional-features">Additional Features</a>, the <code>upper</code> set variable as used here matches as if it is <code>((?:A|B|CC|D|E|FF|G))</code>, showing the enclosing capturing group. When text from the input context matches this expression, and all above conditions are met, the mapping proceeds as follows:</p>
</li>
</ul>
<ol>
<li><p>The portion of the input context, such as <code>CC</code>, is matched against the above calculated pattern.</p>
</li>
<li><p>The position within the <code>from=</code> variable (<code>upper</code>) is calculated. The regex match may not have this information, but the matched substring <code>CC</code> can be compared against the tokenized input variable: <code>A</code>, <code>B</code>, <code>CC</code>, <code>D</code>, ‚Ä¶&nbsp;to find that the 3rd item matches exactly.</p>
</li>
<li><p>The same position within the <code>to=</code> variable (<code>lower</code>) is calculated. The 3rd item is <code>c</code>.</p>
</li>
<li><p><code>CC</code> in the input context is replaced with <code>c</code>, and processing proceeds to the next <code>transformGroup</code>.</p>
</li>
</ol>
</li>
<li><p><strong>Emit a marker</strong></p>
<p>  <code>\m{Some_marker}</code></p>
<p>  Emits the named mark. Also see <a href="#markers">Markers</a>.</p>
</li>
</ul><hr><h3 id="Element_reorder"><a name="element-reorder" href="#Element_reorder">Element: reorder</a></h3><p>The reorder transform consists of a <a href="#element-transformgroup"><code>&lt;transformGroup&gt;</code></a> element containing <code>&lt;reorder&gt;</code> elements.  Multiple such <code>&lt;transformGroup&gt;</code> elements may be contained in an enclosing <code>&lt;transforms&gt;</code> element.</p><p>One or more <a href="#element-import"><code>&lt;import&gt;</code></a> elements are allowed to precede the <code>&lt;reorder&gt;</code> elements.</p><p>This transform has the job of reordering sequences of characters that have been typed, from their typed order to the desired output order. The primary concern in this transform is to sort combining marks into their correct relative order after a base, as described in this section. The reorder transforms can be quite complex, keyboard layouts will almost always import them.</p><p>The reordering algorithm consists of four parts:</p><ol>
<li>Create a sort key for each character in the input string. A sort key has 4 parts (primary, index, tertiary, quaternary):<ul>
<li>The <strong>primary weight</strong> is the primary order value.</li>
<li>The <strong>secondary weight</strong> is the index, a position in the input string, usually of the character itself, but it may be of a character earlier in the string.</li>
<li>The <strong>tertiary weight</strong> is a tertiary order value (defaulting to 0).</li>
<li>The <strong>quaternary weight</strong> is the index of the character in the string. This is solely to ensure a stable sort for sequences of characters with the same tertiary weight.</li>
</ul>
</li>
<li>Mark each character as to whether it is a prebase character, one that is typed before the base and logically stored after. Thus it will have a primary order &gt; 0.</li>
<li>Use the sort key and the prebase mark to identify runs. A run starts with a prefix that contains any prebase characters and a single base character whose primary and tertiary key is 0. The run extends until, but not including, the start of the prefix of the next run or end of the string.<ul>
<li><code>run := preBase* (primary=0 &amp;&amp; tertiary=0) ((primary‚â†0 || tertiary‚â†0) &amp;&amp; !preBase)*</code></li>
</ul>
</li>
<li>Sort the character order of each character in the run based on its sort key.</li>
</ol><p>The primary order of a character with the Unicode property <code>Canonical_Combining_Class</code> (ccc) of 0 may well not be 0. In addition, a character may receive a different primary order dependent on context. For example, in the Devanagari sequence ka halant ka, the first ka would have a primary order 0 while the halant ka sequence would give both halant and the second ka a primary order &gt; 0, for example 2. Note that ‚Äúbase‚Äù character in this discussion is not a Unicode base character. It is instead a character with primary=0.</p><p>In order to get the characters into the correct relative order, it is necessary not only to order combining marks relative to the base character, but also to order some combining marks in a subsequence following another combining mark. For example in Devanagari, a nukta may follow a consonant character, but it may also follow a conjunct consisting of consonant, halant, consonant. Notice that the second consonant is not, in this model, the start of a new run because some characters may need to be reordered to before the first base, for example repha. The repha would get primary &lt; 0, and be sorted before the character with order = 0, which is, in the case of Devanagari, the initial consonant of the orthographic syllable.</p><p>The reorder transform consists of <code>&lt;reorder&gt;</code> elements encapsulated in a <code>&lt;transformGroup&gt;</code> element. Each element is a rule that matches against a string of characters with the action of setting the various ordering attributes (<code>primary</code>, <code>tertiary</code>, <code>tertiaryBase</code>, <code>preBase</code>) for the matched characters in the string.</p><p>The relative ordering of <code>&lt;reorder&gt;</code> elements is not significant.</p><p><strong>Syntax</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- one or more &lt;import/&gt; elements are allowed at this point --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{combination of characters}"</span>
    [<span class="hljs-attr">before</span>=<span class="hljs-string">"{look-behind required match}"</span>]
    [<span class="hljs-attr">order</span>=<span class="hljs-string">"{list of weights}"</span>]
    [<span class="hljs-attr">tertiary</span>=<span class="hljs-string">"{list of weights}"</span>]
    [<span class="hljs-attr">tertiaryBase</span>=<span class="hljs-string">"{list of true/false}"</span>]
    [<span class="hljs-attr">preBase</span>=<span class="hljs-string">"{list of true/false}"</span>] /&gt;</span>
    <span class="hljs-comment">&lt;!-- other &lt;reorder/&gt; elements... --&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><blockquote>
<small>

<p>Parents: <a href="#Element_transformGroup">transformGroup</a>
Children: <em>none</em>
Occurrence: optional, multiple</p>
</small>
</blockquote><p><em>Attribute:</em> <code>from</code> (required)</p><blockquote>
<p>This attribute contains a string of elements. Each element matches one character and may consist of a codepoint or a UnicodeSet (both as defined in <a href="tr35.html#Unicode_Sets">UTS #35 Part One</a>).</p>
</blockquote><p><em>Attribute:</em> <code>before</code></p><blockquote>
<p>This attribute contains the element string that must match the string immediately preceding the start of the string that the @from matches.</p>
</blockquote><p><em>Attribute:</em> <code>order</code></p><blockquote>
<p>This attribute gives the primary order for the elements in the matched string in the <code>@from</code> attribute. The value is a simple integer between -128 and +127 inclusive, or a space separated list of such integers. For a single integer, it is applied to all the elements in the matched string. Details of such list type attributes are given after all the attributes are described. If missing, the order value of all the matched characters is 0. We consider the order value for a matched character in the string.</p>
<ul>
<li>If the value is 0 and its tertiary value is 0, then the character is the base of a new run.</li>
<li>If the value is 0 and its tertiary value is non-zero, then it is a normal character in a run, with ordering semantics as described in the <code>@tertiary</code> attribute.</li>
<li>If the value is negative, then the character is a primary character and will reorder to be before the base of the run.</li>
<li>If the value is positive, then the character is a primary character and is sorted based on the order value as the primary key following a previous base character.</li>
</ul>
<p>A character with a zero tertiary value is a primary character and receives a sort key consisting of:</p>
<ul>
<li>Primary weight is the order value</li>
<li>Secondary weight is the index of the character. This may be any value (character index, codepoint index) such that its value is greater than the character before it and less than the character after it.</li>
<li>Tertiary weight is 0.</li>
<li>Quaternary weight is the same as the secondary weight.</li>
</ul>
</blockquote><p><em>Attribute:</em> <code>tertiary</code></p><blockquote>
<p>This attribute gives the tertiary order value to the characters matched. The value is a simple integer between -128 and +127 inclusive, or a space separated list of such integers. If missing, the value for all the characters matched is 0. We consider the tertiary value for a matched character in the string.</p>
<ul>
<li>If the value is 0 then the character is considered to have a primary order as specified in its order value and is a primary character.</li>
<li>If the value is non zero, then the order value must be zero otherwise it is an error. The character is considered as a tertiary character for the purposes of ordering.</li>
</ul>
<p>A tertiary character receives its primary order and index from a previous character, which it is intended to sort closely after. The sort key for a tertiary character consists of:</p>
<ul>
<li>Primary weight is the primary weight of the primary character..</li>
<li>Secondary weight is the index of the primary character, not the tertiary character</li>
<li>Tertiary weight is the tertiary value for the character.</li>
<li>Quaternary weight is the index of the tertiary character.</li>
</ul>
</blockquote><p><em>Attribute:</em> <code>tertiaryBase</code></p><blockquote>
<p>This attribute is a space separated list of <code>"true"</code> or <code>"false"</code> values corresponding to each character matched. It is illegal for a tertiary character to have a true <code>tertiaryBase</code> value. For a primary character it marks that this character may have tertiary characters moved after it. When calculating the secondary weight for a tertiary character, the most recently encountered primary character with a true <code>tertiaryBase</code> attribute is used. Primary characters with an <code>@order</code> value of 0 automatically are treated as having <code>tertiaryBase</code> true regardless of what is specified for them.</p>
</blockquote><p><em>Attribute:</em> <code>preBase</code></p><blockquote>
<p>This attribute gives the prebase attribute for each character matched. The value may be <code>"true"</code> or <code>"false"</code> or a space separated list of such values. If missing the value for all the characters matched is false. It is illegal for a tertiary character to have a true prebase value.</p>
<p>If a primary character has a true prebase value then the character is marked as being typed before the base character of a run, even though it is intended to be stored after it. The primary order gives the intended position in the order after the base character, that the prebase character will end up. Thus <code>@order</code> shall not be 0. These characters are part of the run prefix. If such characters are typed then, in order to give the run a base character after which characters can be sorted, an appropriate base character, such as a dotted circle, is inserted into the output run, until a real base character has been typed. A value of <code>"false"</code> indicates that the character is not a prebase.</p>
</blockquote><p>For <code>@from</code> attributes with a match string length greater than 1, the sort key information (<code>@order</code>, <code>@tertiary</code>, <code>@tertiaryBase</code>, <code>@preBase</code>) may consist of a space-separated list of values, one for each element matched. The last value is repeated to fill out any missing values. Such a list may not contain more values than there are elements in the <code>@from</code> attribute:</p><pre><code class="language-java"><span class="hljs-keyword">if</span> <span class="hljs-title function_">len</span><span class="hljs-params">(<span class="hljs-meta">@from</span>)</span> &lt; len(<span class="hljs-meta">@list</span>) then error
<span class="hljs-keyword">else</span>
    <span class="hljs-keyword">while</span> <span class="hljs-title function_">len</span><span class="hljs-params">(<span class="hljs-meta">@from</span>)</span> &gt; len(<span class="hljs-meta">@list</span>)
        append <span class="hljs-title function_">lastitem</span><span class="hljs-params">(<span class="hljs-meta">@list</span>)</span> to <span class="hljs-meta">@list</span>
    endwhile
endif
</code></pre><p><strong>Example</strong></p><p>For example, consider the Northern Thai (<code>nod-Lana</code>, Tai Tham script) word: ·®°·©†·©Ö·©´·©∂ 'roasted'. This is ideally encoded as the following:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
<th><em>o</em></th>
<th><em>t2</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A60</td>
<td>1A45</td>
<td>1A6B</td>
<td>1A76</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>0</td>
<td>230</td>
</tr>
</tbody></table><p>(That sequence is already in NFC format.)</p><p>Some users may type the upper component of the vowel first, and the tone before or after the lower component. Thus someone might type it as:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>t2</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A76</td>
<td>1A60</td>
<td>1A45</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>230</td>
<td>9</td>
<td>0</td>
</tr>
</tbody></table><p>The Unicode NFC format of that typed value reorders to:</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>sakot</em></th>
<th><em>t2</em></th>
<th><em>wa</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A60</td>
<td>1A76</td>
<td>1A45</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>9</td>
<td>230</td>
<td>0</td>
</tr>
</tbody></table><p>Finally, the user might also type in the sequence with the tone <em>after</em> the lower component.</p><table>
<thead>
<tr>
<th>name</th>
<th><em>kha</em></th>
<th><em>o</em></th>
<th><em>sakot</em></th>
<th><em>wa</em></th>
<th><em>t2</em></th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>1A21</td>
<td>1A6B</td>
<td>1A60</td>
<td>1A45</td>
<td>1A76</td>
</tr>
<tr>
<td>ccc</td>
<td>0</td>
<td>0</td>
<td>9</td>
<td>0</td>
<td>230</td>
</tr>
</tbody></table><p>(That sequence is already in NFC format.)</p><p>We want all of these sequences to end up ordered as the first. To do this, we use the following rules:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"127"</span> /&gt;</span>      <span class="hljs-comment">&lt;!-- max possible order --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"42"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1A75-\u1A79]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"55"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B[\u1A75-\u1A79]"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"\u1A6B"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1A60[\u1A75-\u1A79]\u1A45"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"10 55 10"</span> /&gt;</span>
</code></pre><p>The first reorder is the default ordering for the <em>sakot</em> which allows for it to be placed anywhere in a sequence, but moves any non-consonants that may immediately follow it, back before it in the sequence. The next two rules give the orders for the top vowel component and tone marks respectively. The next three rules give the <em>sakot</em> and <em>wa</em> characters a primary order that places them before the <em>o</em>. Notice particularly the final reorder rule where the <em>sakot</em>+<em>wa</em> is split by the tone mark. This rule is necessary in case someone types into the middle of previously normalized text.</p><p><code>&lt;reorder&gt;</code> elements are priority ordered based first on the length of string their <code>@from</code> attribute matches and then the sum of the lengths of the strings their <code>@before</code> attribute matches.</p><h4 id="using-import-with-reorder-elements">Using <code>&lt;import&gt;</code> with <code>&lt;reorder&gt;</code> elements</h4><p>This section describes the impact of using <a href="#element-import"><code>import</code></a> elements with <code>&lt;reorder&gt;</code> elements.</p><p>The @from string in a <code>&lt;reorder&gt;</code> element describes a set of strings that it matches. This also holds for the <code>@before</code> attribute. The <strong>intersection</strong> of any two <code>&lt;reorder&gt;</code> elements consists of the intersections of their <code>@from</code> and <code>@before</code> string sets. Tooling should warn users if the intersection between any two <code>&lt;reorder&gt;</code> elements in the same <code>&lt;transformGroup&gt;</code> element to be non empty prior to processing imports.</p><p>If two <code>&lt;reorder&gt;</code> elements have a non empty intersection, then they are split and merged. They are split such that where there were two <code>&lt;reorder&gt;</code> elements, there are, in effect (but not actuality), three elements consisting of:</p><ul>
<li><code>@from</code>, <code>@before</code> that match the intersection of the two rules. The other attributes are merged, as described below.</li>
<li><code>@from</code>, <code>@before</code> that match the set of strings in the first rule not in the intersection with the other attributes from the first rule.</li>
<li><code>@from</code>, <code>@before</code> that match the set of strings in the second rule not in the intersection, with the other attributes from the second rule.</li>
</ul><p>When merging the other attributes, the second rule is taken to have priority (being an override of the earlier element). Where the second rule does not define the value for a character but the first does, the value is taken from the first rule, otherwise it is taken from the second rule.</p><p>Notice that it is possible for two rules to match the same string, but for them not to merge because the distribution of the string across <code>@before</code> and <code>@from</code> is different. For example, the following would not merge:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"ab"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"cd"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">before</span>=<span class="hljs-string">"a"</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"bcd"</span> /&gt;</span>
</code></pre><p>After <code>&lt;reorder&gt;</code> elements merge, the resulting <code>reorder</code> elements are sorted into priority order for matching.</p><p>Consider this fragment from a shared reordering for the Myanmar script:</p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- File: "myanmar-reordering.xml" --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- medial-r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u103C"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"20"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- [medial-wa or shan-medial-wa] --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103D\u1082]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"25"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- [medial-ha or shan-medial-wa]+asat = Mon asat --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103E\u1082]\u103A"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"27"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- [medial-ha or mon-medial-wa] --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103E\u1060]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"27"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- [e-vowel (U+1031) or shan-e-vowel (U+1084)] --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1031\u1084]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"30"</span> /&gt;</span>

    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u102D\u102E\u1033-\u1035\u1071-\u1074\u1085\u109D\uA9E5]"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"35"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><p>A particular Myanmar keyboard layout can have these <code>reorder</code> elements:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"myanmar-reordering.xml"</span>/&gt;</span> <span class="hljs-comment">&lt;!-- import the above transformGroup --&gt;</span>
    <span class="hljs-comment">&lt;!-- Kinzi --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1004\u103A\u1039"</span> <span class="hljs-attr">order</span>=<span class="hljs-string">"-1"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- e-vowel --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1031"</span> <span class="hljs-attr">preBase</span>=<span class="hljs-string">"1"</span> /&gt;</span>

    <span class="hljs-comment">&lt;!-- medial-r --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u103C"</span> <span class="hljs-attr">preBase</span>=<span class="hljs-string">"1"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><p>The effect of this is that the <em>e-vowel</em> will be identified as a prebase and will have an order of 30. Likewise a <em>medial-r</em> will be identified as a prebase and will have an order of 20. Notice that a <em>shan-e-vowel</em> (<code>\u1084</code>) will not be identified as a prebase (even if it should be!). The <em>kinzi</em> is described in the layout since it moves something across a run boundary. By separating such movements (prebase or moving to in front of a base) from the shared ordering rules, the shared ordering rules become a self-contained combining order description that can be used in other keyboards or even in other contexts than keyboarding.</p><h4 id="example-post-reorder-transforms">Example Post-reorder transforms</h4><p>It may be desired to perform additional processing following reorder operations.  This may be aaccomplished by adding an additional <code>&lt;transformGroup&gt;</code> element after the reorders.</p><p>First, a partial example from Khmer where split vowels are combined after reordering.</p><pre><code class="language-xml">‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u17C1\u17B8"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u17BE"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u17C1\u17B6"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u17C4"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><p>Another partial example allows a keyboard implementation to prevent people typing two lower vowels in a Burmese cluster:</p><pre><code class="language-xml">‚Ä¶
<span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">reorder</span>&nbsp;‚Ä¶ /&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u102F\u1030\u1048\u1059][\u102F\u1030\u1048\u1059]"</span>  /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
</code></pre><hr><h3 id="Element_backspaces"><a name="transform-typebackspace" href="#Element_backspaces">transform type="backspace"</a></h3><p>The <code>&lt;transforms type="backspace"&gt;</code> describe an optional transform that is not applied on input of normal characters, but is only used to perform extra backspace modifications to previously committed text.</p><p>When the backspace key is pressed, the <code>&lt;transforms type="backspace"&gt;</code> element (if present) is processed, and then the <code>&lt;transforms type="simple"&gt;</code> element (if processed) as with any other key.</p><p>Keyboarding applications typically work, but are not required to, in one of two modes:</p><p><strong><em>text entry</em></strong></p><blockquote>
<p>text entry happens while a user is typing new text. A user typically wants the backspace key to undo whatever they last typed, whether or not they typed things in the 'right' order.</p>
</blockquote><p><strong><em>text editing</em></strong></p><blockquote>
<p>text editing happens when a user moves the cursor into some previously entered text which may have been entered by someone else. As such, there is no way to know in which order things were typed, but a user will still want appropriate behaviour when they press backspace. This may involve deleting more than one character or replacing a sequence of characters with a different sequence.</p>
</blockquote><p>In text editing mode, different keyboard layouts may behave differently in the same textual context. The backspace transform allows the keyboard layout to specify the effect of pressing backspace in a particular textual context. This is done by specifying a set of backspace rules that match a string before the cursor and replace it with another string. The rules are expressed within a <code>transforms type="backspace"</code> element.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"backspace"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"{combination of characters}"</span> [<span class="hljs-attr">to</span>=<span class="hljs-string">"{output}"</span>] /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p><strong>Example</strong></p><p>For example, consider deleting a Devanagari ksha ‡§ï‡•ç‡§∂:</p><p>While this character is made up of three codepoints, the following rule causes all three to be deleted by a single press of the backspace.</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"backspace"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u0915\u094D\u0936"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p>Note that the optional attribute <code>@to</code> is omitted, since the whole string is being deleted. This is not uncommon in backspace transforms.</p><p>A more complex example comes from a Burmese visually ordered keyboard:</p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"backspace"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- Kinzi --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1004\u101B\u105A]\u103A\u1039"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- subjoined consonant --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021\u1050\u1051\u105A-\u105D]"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- tone mark --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u102B\u103A"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- Handle prebases --&gt;</span>
        <span class="hljs-comment">&lt;!-- diacritics stored before e-vowel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103A-\u103F\u105E-\u1060\u1082]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u1031"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- diacritics stored before medial r --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u103A-\u103B\u105E-\u105F]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u103C"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- subjoined consonant before e-vowel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u1031"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- base consonant before e-vowel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1000-\u102A\u103F-\u1049\u104E]\u1031"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\m{prebase}\u1031"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- subjoined consonant before medial r --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\u1039[\u1000-\u101C\u101E\u1020\u1021]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\u103C"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- base consonant before medial r --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"[\u1000-\u102A\u103F-\u1049\u104E]\u103C"</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"\m{prebase}\u103C"</span> /&gt;</span>

        <span class="hljs-comment">&lt;!-- delete lone medial r or e-vowel --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"\m{prebase}[\u1031\u103C]"</span> /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><p>The above example is simplified, and doesn't fully handle the interaction between medial-r and e-vowel.</p><blockquote>
<p>The character <code>\m{prebase}</code> does not represent a literal character, but is instead a special marker, used as a "filler string". When a keyboard implementation handles a user pressing a key that inserts a prebase character, it also has to insert a special filler string before the prebase to ensure that the prebase character does not combine with the previous cluster. See the reorder transform for details. See <a href="#markers">markers</a> for the <code>\m</code> syntax.</p>
</blockquote><p>The first three transforms above delete various ligatures with a single keypress. The other transforms handle prebase characters. There are two in this Burmese keyboard. The transforms delete the characters preceding the prebase character up to base which gets replaced with the prebase filler string, which represents a null base. Finally the prebase filler string + prebase is deleted as a unit.</p><p>If no specified transform among all <code>transformGroup</code>s under the <code>&lt;transforms type="backspace"&gt;</code> element matches, a default will be used instead ‚Äî an implied final transform that simply deletes the codepoint at the end of the input context. This implied transform is effectively similar to the following code sample, even though the <code>*</code> operator is not actually allowed in <code>from=</code>.  See the documentation for <em>Match a single Unicode codepoint</em> under <a href="#regex-like-syntax">transform syntax</a> and <a href="#markers">markers</a>, above.</p><p>It is important that implementations do not by default delete more than one non-marker codepoint at a time, except in the case of emoji clusters. Note that implementations will vary in the emoji handling due to the iterative nature of successive Unicode releases. See <a href="https://www.unicode.org/reports/tr51/#Emoji_Modifiers_in_Text">UTS#51 ¬ß2.4.2: Emoji Modifiers in Text</a></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">transforms</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"backspace"</span>&gt;</span>
    <span class="hljs-comment">&lt;!-- Other explicit transforms --&gt;</span>

    <span class="hljs-comment">&lt;!-- Final implicit backspace transform: Delete the final codepoint. --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">transformGroup</span>&gt;</span>
        <span class="hljs-comment">&lt;!-- (:?\m{.})*  - matches any number of contiguous markers --&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">transform</span> <span class="hljs-attr">from</span>=<span class="hljs-string">"(:?\m{.})*.(:?\m{.})*"</span> /&gt;</span> <span class="hljs-comment">&lt;!-- deletes any number of markers directly on either side of the final pre-caret codepoint --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">transformGroup</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">transforms</span>&gt;</span>
</code></pre><hr><h2 id="Invariants"><a name="invariants" href="#Invariants">Invariants</a></h2><p>Beyond what the DTD imposes, certain other restrictions on the data are imposed on the data.
Please note the constraints given under each element section above.
DTD validation alone is not sufficient to verify a keyboard file.</p><!--
TODO: Rewrite this? Probably push out to each element's section?

3.  No `keyMap[@modifiers]` value can overlap with another `keyMap[@modifiers]` value.
    * eg you can't have `"RAlt Ctrl"` in one `keyMap`, and `"Alt Shift"` in another (because Alt = RAltLAlt).
4.  Every sequence of characters in a `transform[@from]` value must be a concatenation of two or more `map[@to]` values.
    * eg with `<transform from="xyz" to="q">` there must be some map values to get there, such as `<map... to="xy">` & `<map... to="z">`
5.  If the base and chars values for `modifiers=""` are all identical, and there are no longpresses, that `keyMap` must not appear (??)
6.  There will never be overlaps among modifier values.
7.  A modifier set will never have ? (optional) on all values
    * eg, you'll never have `RCtrl?Caps?LShift?`
8.  Every `base[@base`] value must be unique.
9. A `modifier` attribute value will aways be minimal, observing the following simplification rules.

| Notation                                 | Notes |
|------------------------------------------|-------|
| Lower case character (e.g. _x_ )          | Interpreted as any combination of modifiers. <br/> (e.g. _x_ = CtrlShiftOption) |
| Upper-case character (e.g. _Y_ )          | Interpreted as a single modifier key (which may or may not have an L and R variant) <br/> (e.g. _Y_ = Ctrl, _RY_ = RCtrl, etc.) |
| Y? ‚áî Y ‚à® ‚àÖ <br/> Y ‚áî LY ‚à® RY ‚à® LYRY | E.g. Opt? ‚áî ROpt ‚à® LOpt ‚à® ROptLOpt ‚à® ‚àÖ <br/> E.g. Opt ‚áî ROpt ‚à® LOpt ‚à® ROptLOpt |

| Axiom                                       | Example                                      |
|---------------------------------------------|----------------------------------------------|
| xY ‚à® x ‚áí xY?                              | OptCtrlShift OptCtrl ‚Üí OptCtrlShift?         |
| xRY ‚à® xY? ‚áí xY? <br/> xLY ‚à® xY? ‚áí xY?   | OptCtrlRShift OptCtrlShift? ‚Üí OptCtrlShift?  |
| xRY? ‚à® xY ‚áí xY? <br/> xLY? ‚à® xY ‚áí xY?   | OptCtrlRShift? OptCtrlShift ‚Üí OptCtrlShift?  |
| xRY? ‚à® xY? ‚áí xY? <br/> xLY? ‚à® xY? ‚áí xY? | OptCtrlRShift? OptCtrlShift? ‚Üí OptCtrlShift? |
| xRY ‚à® xY ‚áí xY <br/> xLY ‚à® xY ‚áí xY       | OptCtrlRShift OptCtrlShift ‚Üí OptCtrlShift?   |
| LY?RY?                                      | OptRCtrl?LCtrl? ‚Üí OptCtrl?                   |
| xLY? ‚ãÅ xLY ‚áí xLY?                          |                                              |
| xY? ‚ãÅ xY ‚áí xY?                             |                                              |
| xY? ‚ãÅ x ‚áí xY?                              |                                              |
| xLY? ‚ãÅ x ‚áí xLY?                            |                                              |
| xLY ‚ãÅ x ‚áí xLY?                             |                                              |
--><hr><h2 id="Keyboard_IDs"><a name="keyboard-ids" href="#Keyboard_IDs">Keyboard IDs</a></h2><p>There is a set of subtags that help identify the keyboards. Each of these are used after the <code>"t-k0"</code> subtags to help identify the keyboards. The first tag appended is a mandatory platform tag followed by zero or more tags that help differentiate the keyboard from others with the same locale code.</p><h3 id="Principles_for_Keyboard_IDs"><a name="principles-for-keyboard-ids" href="#Principles_for_Keyboard_IDs">Principles for Keyboard IDs</a></h3><p>The following are the design principles for the IDs.</p><ol>
<li>BCP47 compliant.<ol>
<li>Eg, <code>en</code>, <code>sr-Cyrl</code>, or <code>en-t-k0-extended</code>.</li>
</ol>
</li>
<li>Use the minimal language id based on <code>likelySubtags</code>&nbsp;(see <a href="tr35.html#Likely_Subtags">Part 1: Likely Subtags</a>)<ol>
<li>Eg, instead of <code>fa-Arab</code>, use <code>fa</code>.</li>
<li>The data is in <a href="https://github.com/unicode-org/cldr/blob/main/common/supplemental/likelySubtags.xml">https://github.com/unicode-org/cldr/blob/main/common/supplemental/likelySubtags.xml</a></li>
</ol>
</li>
<li>Keyboard files should be platform-independent, however, if included, a platform id is the first subtag after <code>-t-k0-</code>. If a keyboard on the platform changes over time, both are dated, eg <code>bg-t-k0-chromeos-2011</code>. When selecting, if there is no date, it means the latest one.</li>
<li>Keyboards are only tagged that differ from the "standard for each language". That is, for each language on a platform, there will be a keyboard with no subtags. Subtags with common semantics across languages and platforms are used, such as <code>-extended</code>, <code>-phonetic</code>, <code>-qwerty</code>, <code>-qwertz</code>, <code>-azerty</code>, ‚Ä¶</li>
<li>In order to get to 8 letters, abbreviations are reused that are already in <a href="https://github.com/unicode-org/cldr/blob/main/common/bcp47/">bcp47</a> -u/-t extensions and in <a href="https://www.iana.org/assignments/language-subtag-registry">language-subtag-registry</a> variants, eg for Traditional use <code>-trad</code> or <code>-traditio</code> (both exist in <a href="https://github.com/unicode-org/cldr/blob/main/common/bcp47/">bcp47</a>).</li>
<li>Multiple languages cannot be indicated in the locale id, so the predominant target is used.<ol>
<li>For Finnish + Sami, use <code>fi-t-k0-smi</code> or <code>extended-smi</code></li>
<li>The <a href="#Element_locales"><code>&lt;locales&gt;</code></a> element may be used to identify additional languages.</li>
</ol>
</li>
<li>In some cases, there are multiple subtags, like <code>en-US-t-k0-chromeos-intl-altgr.xml</code></li>
<li>Otherwise, platform names are used as a guide.</li>
</ol><p><strong>Examples</strong></p><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Serbian Latin --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"sr-Latn"</span>/&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Serbian Cyrillic --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"sr-Cyrl"</span>/&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Pan Nigerian Keyboard--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"mul-Latn-NG-t-k0-panng"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locales</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ha"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ig"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- others ‚Ä¶ --&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">locales</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><pre><code class="language-xml"><span class="hljs-comment">&lt;!-- Finnish Keyboard including Skolt Sami --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboard</span> <span class="hljs-attr">locale</span>=<span class="hljs-string">"fi-t-k0-smi"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locales</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">locale</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"sms"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">locales</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboard</span>&gt;</span>
</code></pre><hr><h2 id="Platform_Behaviors_in_Edge_Cases"><a name="platform-behaviors-in-edge-cases" href="#Platform_Behaviors_in_Edge_Cases">Platform Behaviors in Edge Cases</a></h2><table>
<thead>
<tr>
<th>Platform</th>
<th>No modifier combination match is available</th>
<th>No map match is available for key position</th>
<th>Transform fails (i.e. if ^d is pressed when that transform does not exist)</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome OS</td>
<td>Fall back to base</td>
<td>Fall back to character in a keyMap with same "level" of modifier combination. If this character does not exist, fall back to (n-1) level. (This is handled data-generation-side.) <br> In the spec: No output</td>
<td>No output at all</td>
</tr>
<tr>
<td>Mac OS X</td>
<td>Fall back to base (unless combination is some sort of keyboard shortcut, e.g. cmd-c)</td>
<td>No output</td>
<td>Both keys are output separately</td>
</tr>
<tr>
<td>Windows</td>
<td>No output</td>
<td>No output</td>
<td>Both keys are output separately</td>
</tr>
</tbody></table><hr><h2 id="CLDR_VKey_Enum"><a name="cldr-vkey-enum" href="#CLDR_VKey_Enum">CLDR VKey Enum</a></h2><p>In the following chart, ‚ÄúCLDR Name‚Äù indicates the value used with the <code>from</code> and <code>to</code> attributes of the <a href="#Element_vkey">vkey</a> element.</p><table>
<thead>
<tr>
<th>CLDR Name</th>
<th>US English ISO</th>
<th>Hex<sup>1</sup></th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>SPACE</td>
<td>A03</td>
<td>0x20</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>E10</td>
<td>0x30</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>E01</td>
<td>0x31</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>E02</td>
<td>0x32</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>E03</td>
<td>0x33</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>E04</td>
<td>0x34</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>E05</td>
<td>0x35</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>E06</td>
<td>0x36</td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>E07</td>
<td>0x37</td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>E08</td>
<td>0x38</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>E09</td>
<td>0x39</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>C01</td>
<td>0x41</td>
<td></td>
</tr>
<tr>
<td>B</td>
<td>B05</td>
<td>0x42</td>
<td></td>
</tr>
<tr>
<td>C</td>
<td>B03</td>
<td>0x43</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>C03</td>
<td>0x44</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>D03</td>
<td>0x45</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>C04</td>
<td>0x46</td>
<td></td>
</tr>
<tr>
<td>G</td>
<td>C05</td>
<td>0x47</td>
<td></td>
</tr>
<tr>
<td>H</td>
<td>C06</td>
<td>0x48</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>D08</td>
<td>0x49</td>
<td></td>
</tr>
<tr>
<td>J</td>
<td>C07</td>
<td>0x4A</td>
<td></td>
</tr>
<tr>
<td>K</td>
<td>C08</td>
<td>0x4B</td>
<td></td>
</tr>
<tr>
<td>L</td>
<td>C09</td>
<td>0x4C</td>
<td></td>
</tr>
<tr>
<td>M</td>
<td>B07</td>
<td>0x4D</td>
<td></td>
</tr>
<tr>
<td>N</td>
<td>B06</td>
<td>0x4E</td>
<td></td>
</tr>
<tr>
<td>O</td>
<td>D09</td>
<td>0x4F</td>
<td></td>
</tr>
<tr>
<td>P</td>
<td>D10</td>
<td>0x50</td>
<td></td>
</tr>
<tr>
<td>Q</td>
<td>D01</td>
<td>0x51</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>D04</td>
<td>0x52</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>C02</td>
<td>0x53</td>
<td></td>
</tr>
<tr>
<td>T</td>
<td>D05</td>
<td>0x54</td>
<td></td>
</tr>
<tr>
<td>U</td>
<td>D07</td>
<td>0x55</td>
<td></td>
</tr>
<tr>
<td>V</td>
<td>B05</td>
<td>0x56</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>D02</td>
<td>0x57</td>
<td></td>
</tr>
<tr>
<td>X</td>
<td>B02</td>
<td>0x58</td>
<td></td>
</tr>
<tr>
<td>Y</td>
<td>D06</td>
<td>0x59</td>
<td></td>
</tr>
<tr>
<td>Z</td>
<td>B01</td>
<td>0x5A</td>
<td></td>
</tr>
<tr>
<td>SEMICOLON</td>
<td>C10</td>
<td>0xBA</td>
<td></td>
</tr>
<tr>
<td>EQUAL</td>
<td>E12</td>
<td>0xBB</td>
<td></td>
</tr>
<tr>
<td>COMMA</td>
<td>B08</td>
<td>0xBC</td>
<td></td>
</tr>
<tr>
<td>HYPHEN</td>
<td>E11</td>
<td>0xBD</td>
<td></td>
</tr>
<tr>
<td>PERIOD</td>
<td>B09</td>
<td>0xBE</td>
<td></td>
</tr>
<tr>
<td>SLASH</td>
<td>B10</td>
<td>0xBF</td>
<td></td>
</tr>
<tr>
<td>GRAVE</td>
<td>E00</td>
<td>0xC0</td>
<td></td>
</tr>
<tr>
<td>LBRACKET</td>
<td>D11</td>
<td>0xDB</td>
<td></td>
</tr>
<tr>
<td>BACKSLASH</td>
<td>D13</td>
<td>0xDC</td>
<td></td>
</tr>
<tr>
<td>RBRACKET</td>
<td>D12</td>
<td>0xDD</td>
<td></td>
</tr>
<tr>
<td>QUOTE</td>
<td>C11</td>
<td>0xDE</td>
<td></td>
</tr>
<tr>
<td>LESS-THAN</td>
<td>B00</td>
<td>0xE2</td>
<td>102nd key on European layouts, right of left shift.</td>
</tr>
<tr>
<td>ABNT2</td>
<td>B11</td>
<td>0xC1</td>
<td>Extra key, left of right-shift, Brazilian Portuguese ABNT2 keyboards</td>
</tr>
</tbody></table><p>Footnotes:</p><ul>
<li><sup>1</sup> Hex value from Windows, web standards, Keyman, etc.</li>
</ul><hr><h2 id="keyboard-test-data">Keyboard Test Data</h2><p>Keyboard Test Data allows the keyboard author to provide regression test data to validate the repertoire and behavior of a keyboard. Tooling can run these regression tests against an implementation, and can also be used as part of the development cycle to validate that keyboard changes do not deviate from expected behavior.  In the interest of complete coverage, tooling could also indicate whether all keys and gestures in a layout are exercised by the test data.</p><p>Test data files have a separate DTD, named <code>ldmlKeyboardTest.dtd</code>.  Note that multiple test data files can refer to the same keyboard. Test files should be named similarly to the keyboards which they test, such as <code>fr_test.xml</code> to test <code>fr.xml</code>.</p><p>Sample test data files are located in the <code>keyboards/test</code> subdirectory.</p><p>The following describes the structure of a keyboard test file.</p><h3 id="test-doctype">Test Doctype</h3><pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">keyboardTest</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">"../dtd/ldmlKeyboardTest.dtd"</span>&gt;</span>
</code></pre><p>The top level element is named <code>keyboardTest</code>.</p><h3 id="test-element-keyboardtest">Test Element: keyboardTest</h3><blockquote>
<small>

</small><p><small>Children: <a href="#test-element-info">info</a>, <a href="#test-element-repertoire">repertoire</a>, <a href="tr35.html#special"><em>special</em></a>, <a href="#test-element-tests">tests</a>
</small></p>
</blockquote><p>This is the top level element.</p><p><em>Attribute:</em> <code>conformsTo</code> (required)</p><p>The <code>conformsTo</code> attribute here is the same as on the <a href="#Element_Keyboard"><code>&lt;keyboard&gt;</code></a> element.</p><pre><code class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">"1.0"</span> encoding=<span class="hljs-string">"UTF-8"</span>?&gt;</span>
<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">keyboardTest</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">"../dtd/ldmlKeyboardTest.dtd"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keyboardTest</span> <span class="hljs-attr">conformsTo</span>=<span class="hljs-string">"techpreview"</span>&gt;</span>
    ‚Ä¶
<span class="hljs-tag">&lt;/<span class="hljs-name">keyboardTest</span>&gt;</span>
</code></pre><h3 id="test-element-info">Test Element: info</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-keyboardtest">keyboardTest</a></p>
<blockquote>
</blockquote>
</small><p><small>Occurrence: Required, Single
</small></p>
</blockquote><p><em>Attribute:</em> <code>author</code></p><p>This freeform attribute allows for description of the author or authors of this test file.</p><p><em>Attribute:</em> <code>keyboard</code> (required)</p><p>This attribute specifies the keyboard‚Äôs file name, such as <code>fr-t-k0-azerty.xml</code>.</p><p><em>Attribute:</em> <code>name</code> (required)</p><p>This attribute specifies a name for this overall test file. These names could be output to the user during test execution, used to summarize success and failure, or used to select or deselect test components.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">info</span> <span class="hljs-attr">keyboard</span>=<span class="hljs-string">"fr-t-k0-azerty.xml"</span> <span class="hljs-attr">author</span>=<span class="hljs-string">"Team Keyboard"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fr-test"</span> /&gt;</span>
</code></pre><h3 id="test-element-repertoire">Test Element: repertoire</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-keyboardtest">keyboardTest</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element represents a repertoire test, to validate the available characters and their reachability. This test ensures that each of the specified characters is somehow typeable on the keyboard, after transforms have been applied. The characters in the repertoire will be matched against the complete set of possible generated outputs, post-transform, of all keys on the keyboard.</p><p><em>Attribute:</em> <code>name</code> (required)</p><p>This attribute specifies a unique name for this repertoire test. These names could be output to the user during test execution, used to summarize success and failure, or used to select or deselect test components.</p><p><em>Attribute:</em> <code>type</code></p><p>This attribute is one of the following:</p><table>
<thead>
<tr>
<th>type</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>This is the default, indicates that <em>any</em> gesture or keystroke may be used to generate each character</td>
</tr>
<tr>
<td>simple</td>
<td>Each of the characters must be typeable by simple single keystrokes without needing any gestures.</td>
</tr>
<tr>
<td>gesture</td>
<td>The characters are typeable by use of any gestures such as flicks, long presses, or multiple taps.</td>
</tr>
<tr>
<td>flick</td>
<td>The characters are typeable by use of any <code>flick</code> element.</td>
</tr>
<tr>
<td>longPress</td>
<td>The characters are typeable by use of any <code>longPress</code> value.</td>
</tr>
<tr>
<td>multiTap</td>
<td>The characters are typeable by use of any <code>multiTap</code> value.</td>
</tr>
<tr>
<td>hardware</td>
<td>The characters are typeable by use of any simple keystrokes on any hardware layout.</td>
</tr>
</tbody></table><p><em>Attribute:</em> <code>chars</code> (required)</p><p>This attribute specifies a list of characters in UnicodeSet format, which is specified in <a href="tr35.html#Unicode_Sets">UTS #35 Part One</a>.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">repertoire</span> <span class="hljs-attr">chars</span>=<span class="hljs-string">"[a b c d e \u{22}]"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"default"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- taken from CLDR's common/main/fr.xml main exemplars - indicates that all of these characters should be reachable without requiring a gesture.
Note that the 'name' is arbitrary. --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">repertoire</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cldr-fr-main"</span> <span class="hljs-attr">chars</span>=<span class="hljs-string">"[a √† √¢ √¶ b c √ß d e √© √® √™ √´ f g h i √Æ √Ø j k l m n o √¥ ≈ì p q r s t u √π √ª √º v w x y √ø z]"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"simple"</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- taken from CLDR's common/main/fr.xml auxiliary exemplars - indicates that all of these characters should be reachable even if a gesture is required.--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">repertoire</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cldr-fr-auxiliary"</span> <span class="hljs-attr">chars</span>=<span class="hljs-string">"[√° √• √§ √£ ƒÅ ƒá ƒì √≠ √¨ ƒ´ ƒ≥ √± √≥ √≤ √∂ √µ √∏ ≈ô ≈° ≈ø √ü √∫ «î]"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"gesture"</span> /&gt;</span>
</code></pre><p>Note: CLDR‚Äôs extensive <a href="tr35-general.html#Character_Elements">exemplar set</a> data may be useful in validating a language‚Äôs repertoire against a keyboard. Tooling may wish to make use of this data in order to suggest recommended repertoire values for a language.</p><h3 id="test-element-tests">Test Element: tests</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-keyboardtest">keyboardTest</a></p>
<p>Children: <a href="tr35.html#special"><em>special</em></a>, <a href="#test-element-test">test</a></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element specifies a particular suite of <code>&lt;test&gt;</code> elements.</p><p><em>Attribute:</em> <code>name</code> (required)</p><p>This attribute specifies a unique name for this suite of tests. These names could be output to the user during test execution, used to summarize success and failure, or used to select or deselect test components.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">tests</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key-tests"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"key-test"</span>&gt;</span>
        ‚Ä¶
    <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"gestures-test"</span>&gt;</span>
        ‚Ä¶
    <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tests</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">tests</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"transform tests"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"transform test"</span>&gt;</span>
        ‚Ä¶
    <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">tests</span>&gt;</span>
</code></pre><h3 id="test-element-test">Test Element: test</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-tests">tests</a></p>
<p>Children: <a href="#test-element-startContext">startContext</a>, <a href="#test-element-emit">emit</a>, <a href="#test-element-keystroke">keystroke</a>, <a href="#test-element-backspace">backspace</a>, <a href="#test-element-check">check</a>, <a href="tr35.html#special"><em>special</em></a></p>
</small><p><small>Occurrence: Required, Multiple
</small></p>
</blockquote><p>This attribute specifies a specific isolated regression test. Multiple test elements do not interact with each other.</p><p>The order of child elements is significant, with cumulative effects: they must be processed from first to last.</p><p><em>Attribute:</em> <code>name</code> (required)</p><p>This attribute specifies a unique name for this particular test. These names could be output to the user during test execution, used to summarize success and failure, or used to select or deselect test components.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">info</span> <span class="hljs-attr">keyboard</span>=<span class="hljs-string">"fr-t-k0-azerty.xml"</span> <span class="hljs-attr">author</span>=<span class="hljs-string">"Team Keyboard"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"fr-test"</span> /&gt;</span>
</code></pre><h3 id="test-element-startcontext">Test Element: startContext</h3><p>This element specifies pre-existing text in a document, as if prior to the user‚Äôs insertion point. This is useful for testing transforms and reordering. If not specified, the startContext can be considered to be the empty string ("").</p><blockquote>
<small>

<p>Parents: <a href="#Element_test">test</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Single
</small></p>
</blockquote><p><em>Attribute:</em> <code>to</code> (required)</p><p>Specifies the starting context. This text may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">startContext</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"abc\u0022"</span>/&gt;</span>
</code></pre><h3 id="test-element-keystroke">Test Element: keystroke</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-test">test</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element represents a single keystroke or other gesture event, identified by a particular key element.</p><p>Optionally, one of the gesture attributes, either <code>flick</code>, <code>longPress</code>, or <code>tapCount</code> may be specified. If none of the gesture attributes are specified, then a regular keypress is effected on the key.  It is an error to specify more than one gesture attribute.</p><p>If a key is not found, or a particular gesture has no definition, the output should be behave as if the user attempted to perform such an action.  For example, an unspecified <code>flick</code> would result in no output.</p><p>When a key is found, processing continues with the transform and other elements before updating the test output buffer.</p><p><em>Attribute:</em> <code>key</code> (required)</p><p>This attribute specifies a key by means of the key‚Äôs <code>id</code> attribute.</p><p><em>Attribute:</em> <code>flick</code></p><p>This attribute specifies a flick gesture to be performed on the specified key instead of a keypress, such as <code>e</code> or <code>nw se</code>. This value corresponds to the <code>directions</code> attribute of the <a href="#Element_flicks"><code>&lt;flick&gt;</code></a> element.</p><p><em>Attribute:</em> <code>longPress</code></p><p>This attribute specifies that a long press gesture should be performed on the specified key instead of a keypress. For example, <code>longPress="2"</code> indicates that the second character in a longpress series should be chosen. <code>longPress="0"</code> indicates that the <code>longPressDefault</code> value, if any, should be chosen. This corresponds to <code>longPress</code> and <code>longPressDefault</code> on <a href="#Element_key"><code>&lt;key&gt;</code></a>.</p><p><em>Attribute:</em> <code>tapCount</code></p><p>This attribute specifies that a multi-tap gesture should be performed on the specified key instead of a keypress. For example, <code>tapCount="3"</code> indicates that the key should be tapped three times in rapid succession. This corresponds to <code>multiTap</code> on <a href="#Element_key"><code>&lt;key&gt;</code></a>. The minimum tapCount is 2.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"q"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"doublequote"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"s"</span> <span class="hljs-attr">flick</span>=<span class="hljs-string">"nw se"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span> <span class="hljs-attr">longPress</span>=<span class="hljs-string">"1"</span>/&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"E"</span> <span class="hljs-attr">tapCount</span>=<span class="hljs-string">"2"</span>/&gt;</span>
</code></pre><h3 id="test-element-emit">Test Element: emit</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-test">test</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element also represents an input event, except that the input is specified in terms of textual value rather than key or gesture identity. This element is particularly useful for testing transforms.</p><p>Processing of the specified text continues with the transform and other elements before updating the test output buffer.</p><p><em>Attribute:</em> <code>to</code> (required)</p><p>This attribute specifies a string of output text representing a single keystroke or gesture. This string is intended to match the output of a <code>key</code>, <code>flick</code>, <code>longPress</code> or <code>multiTap</code> element or attribute.
Tooling should give a hint if this attribute does not match at least one keystroke or gesture. Note that the specified text is not injected directly into the output buffer.</p><p>This attribute may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">emit</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"s"</span>/&gt;</span>
</code></pre><h3 id="test-element-backspace">Test Element: backspace</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-test">test</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element represents a backspace action, as if the user typed the backspace key</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">backspace</span>/&gt;</span>
</code></pre><h3 id="test-element-check">Test Element: check</h3><blockquote>
<small>

<p>Parents: <a href="#test-element-test">test</a></p>
<p>Children: <em>none</em></p>
</small><p><small>Occurrence: Optional, Multiple
</small></p>
</blockquote><p>This element represents a check on the current output buffer.</p><p><em>Attribute:</em> <code>result</code> (required)</p><p>This attribute specifies the expected resultant text in a document after processing this event and all prior events, and including any <code>startContext</code> text.  This text may be escaped with <code>\u</code> notation, see <a href="#Escaping">Escaping</a>.</p><p><strong>Example</strong></p><pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s\u0022‚Ä¢√©√à"</span>/&gt;</span>
</code></pre><h3 id="test-examples">Test Examples</h3><pre><code class="language-xml">
<span class="hljs-tag">&lt;<span class="hljs-name">test</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"spec-sample"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">startContext</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"abc\u0022"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- simple, key specified by to --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">emit</span> <span class="hljs-attr">to</span>=<span class="hljs-string">"s"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- simple, key specified by id --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"doublequote"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s\u0022"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- flick --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"s"</span> <span class="hljs-attr">flick</span>=<span class="hljs-string">"nw se"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s\u0022‚Ä¢"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- longPress --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"e"</span> <span class="hljs-attr">longPress</span>=<span class="hljs-string">"1"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s\u0022‚Ä¢√©"</span>/&gt;</span>
    <span class="hljs-comment">&lt;!-- multiTap --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">keystroke</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"E"</span> <span class="hljs-attr">tapCount</span>=<span class="hljs-string">"2"</span>/&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">check</span> <span class="hljs-attr">result</span>=<span class="hljs-string">"abc\u0022s\u0022‚Ä¢√©√à"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span>
</code></pre><hr><p>Copyright ¬© 2001‚Äì2023 Unicode, Inc. All Rights Reserved. The Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability for errors or omissions. No liability is assumed for incidental and consequential damages in connection with or arising out of the use of the information or programs contained or accompanying this technical report. The Unicode <a href="https://www.unicode.org/copyright.html">Terms of Use</a> apply.</p><p>Unicode and the Unicode logo are trademarks of Unicode, Inc., and are registered in some jurisdictions.</p></div><script>anchors.add('h1, h2, h3, h4, h5, h6, caption');</script></body></html>